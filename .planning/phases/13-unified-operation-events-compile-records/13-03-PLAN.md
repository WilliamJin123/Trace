---
phase: 13-unified-operation-events-compile-records
plan: 03
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - src/tract/tract.py
  - tests/test_compile_records.py
autonomous: true

must_haves:
  truths:
    - "chat() and generate() automatically create compile records with correct commit hashes and token counts"
    - "Manual compile() calls do NOT create compile records"
    - "CompileRecordRow persists head_hash, token_count, commit_count, token_source"
    - "CompileEffectiveRow persists ordered commit hashes matching CompiledContext.commit_hashes"
    - "Compile records can be queried by tract_id, returning chronological list"
    - "Full test suite passes (all 1057+ existing tests plus new compile record tests)"
    - "Zero references to old compression tables, old cherry-pick types, or old compression_repo anywhere in source or tests"
  artifacts:
    - path: "src/tract/tract.py"
      provides: "Compile record creation in generate()"
      contains: "_compile_record_repo"
    - path: "tests/test_compile_records.py"
      provides: "Tests for compile record persistence"
  key_links:
    - from: "src/tract/tract.py (generate method)"
      to: "src/tract/storage/sqlite.py (SqliteCompileRecordRepository)"
      via: "_compile_record_repo.save_record + add_effective"
---

<objective>
Wire compile record persistence into chat()/generate(), create compile record tests, and run the full test suite to verify zero regressions and zero references to old artifacts.

Purpose: This is the final plan -- it adds the compile record feature (SC-3) and performs the full-codebase verification sweep (SC-8).
Output: Compile records auto-created by chat/generate, new test file, full suite green, zero old references.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-unified-operation-events-compile-records/13-RESEARCH.md
@.planning/phases/13-unified-operation-events-compile-records/13-01-SUMMARY.md
@.planning/phases/13-unified-operation-events-compile-records/13-02-SUMMARY.md
@src/tract/tract.py
@src/tract/protocols.py
@src/tract/storage/sqlite.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire compile records into Tract.generate() and Tract.open()</name>
  <files>
    src/tract/tract.py
  </files>
  <action>
**Wire CompileRecordRepository into Tract:**

1. Add `SqliteCompileRecordRepository` to the imports from `tract.storage.sqlite`.

2. In `__init__()`: add parameter `compile_record_repo: SqliteCompileRecordRepository | None = None`. Store as `self._compile_record_repo`.

3. In `open()`: create `compile_record_repo = SqliteCompileRecordRepository(session)`. Pass it to the `cls(...)` call as `compile_record_repo=compile_record_repo`.

4. In `from_components()`: add optional `compile_record_repo` parameter, store on instance if provided.

**Wire compile records into generate():**

5. In `generate()` method, AFTER step 1 (compile) and BEFORE step 2 (LLM call), add compile record creation:
   ```python
   # 1b. Persist compile record (SC-3: chat/generate auto-create)
   if self._compile_record_repo is not None:
       import uuid as _uuid
       from datetime import datetime as _dt, timezone as _tz
       record_id = _uuid.uuid4().hex
       current_head = self.head
       self._compile_record_repo.save_record(
           record_id=record_id,
           tract_id=self._tract_id,
           head_hash=current_head or "",
           token_count=compiled.token_count,
           commit_count=compiled.commit_count,
           token_source=compiled.token_source,
           params_json=None,  # No compile params for standard calls
           created_at=_dt.now(_tz.utc),
       )
       for pos, commit_hash in enumerate(compiled.commit_hashes):
           self._compile_record_repo.add_effective(record_id, commit_hash, pos)
   ```
   This is placed AFTER compile() succeeds and BEFORE the LLM call, so we record what was sent even if the LLM call fails.

6. **Do NOT add compile record logic to `compile()` itself** -- per SC-3, only chat()/generate() create records. chat() delegates to generate(), so generate() is the single insertion point.

7. Add a public read-only accessor:
   ```python
   def compile_records(self, limit: int = 100) -> list:
       """Get compile records for this tract, newest first.

       Returns list of CompileRecordRow objects, or empty list if
       compile record repository is not available.
       """
       if self._compile_record_repo is None:
           return []
       records = self._compile_record_repo.get_all(self._tract_id)
       return list(reversed(records))[:limit]  # newest first
   ```

8. Add a method to get effective commits for a compile record:
   ```python
   def compile_record_commits(self, record_id: str) -> list[str]:
       """Get the ordered commit hashes for a compile record.

       Returns list of commit hashes in compilation order, or empty list
       if record not found or compile record repository not available.
       """
       if self._compile_record_repo is None:
           return []
       effectives = self._compile_record_repo.get_effectives(record_id)
       return [e.commit_hash for e in effectives]
   ```
  </action>
  <verify>
    Run: `python -c "from tract import Tract; t = Tract.open(); print(hasattr(t, '_compile_record_repo')); print(t._compile_record_repo is not None)"` -- prints True, True.
    Run: `python -c "from tract import Tract; t = Tract.open(); print(t.compile_records())"` -- prints [].
  </verify>
  <done>
    Tract.generate() creates compile records automatically. compile_records() and compile_record_commits() accessors available. Manual compile() does NOT create records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compile record tests + full suite sweep</name>
  <files>
    tests/test_compile_records.py
  </files>
  <action>
**Create `tests/test_compile_records.py`:**

Write comprehensive tests for compile record persistence. Follow existing test patterns (see test_compression_storage.py as rewritten in Plan 01).

Test structure:
- Use `Tract.open()` for integration-level testing (compile records are created through the facade)
- Mock LLM client for chat()/generate() tests (follow patterns from tests/test_tract.py or tests/test_llm.py)

Test cases:

1. **`test_generate_creates_compile_record`**:
   - Open tract with mock LLM client
   - Commit system + user messages
   - Call `t.generate()`
   - Verify `t.compile_records()` returns 1 record
   - Verify record has correct `head_hash`, `token_count > 0`, `commit_count > 0`, `token_source` starts with "tiktoken:"

2. **`test_chat_creates_compile_record`**:
   - Open tract with mock LLM client
   - Commit system prompt
   - Call `t.chat("hello")`
   - Verify compile record created (chat delegates to generate)

3. **`test_compile_record_has_correct_effective_commits`**:
   - Open tract, commit 3 messages
   - Call `t.generate()`
   - Get record via `t.compile_records()[0]`
   - Get effectives via `t.compile_record_commits(record.record_id)`
   - Verify effectives contain exactly the commit hashes from compilation, in order

4. **`test_manual_compile_does_not_create_record`**:
   - Open tract, commit messages
   - Call `t.compile()` (manual)
   - Verify `t.compile_records()` returns empty list

5. **`test_multiple_generates_create_multiple_records`**:
   - Open tract with mock LLM
   - Call generate() 3 times (with user messages between)
   - Verify 3 records exist
   - Verify records are in chronological order (newest first from accessor)

6. **`test_compile_record_params_json`**:
   - Verify params_json is None for standard compile (no special params)

7. **`test_compile_record_survives_session`**:
   - Create compile records, verify they're in the DB
   - Close and reopen the tract on the same DB file
   - Verify records are still there

**Mock LLM client pattern (from existing tests):**
```python
class MockLLMClient:
    def chat(self, messages, **kwargs):
        return {"choices": [{"message": {"content": "mock response"}}],
                "usage": {"prompt_tokens": 10, "completion_tokens": 5, "total_tokens": 15},
                "model": "mock-model"}
    def extract_content(self, response):
        return response["choices"][0]["message"]["content"]
    def extract_usage(self, response):
        return response["usage"]
```

**After writing tests, run the FULL test suite:**

Run: `python -m pytest tests/ -x -q --timeout=300` to verify zero regressions across all 1057+ tests.

**Final sweep -- verify SC-8 (zero old references):**

Run these greps across the ENTIRE repo (src/ and tests/):
- `grep -rn "CompressionRow\|CompressionSourceRow\|CompressionResultRow" src/ tests/` -- must return ZERO
- `grep -rn "CompressionRepository\|SqliteCompressionRepository" src/ tests/` -- must return ZERO
- `grep -rn "compression_repo" src/ tests/` -- must return ZERO
- `grep -rn "CherryPickResult\|CherryPickIssue\|CherryPickError" src/ tests/` -- must return ZERO
- `grep -rn "cherry_pick" src/tract/` -- must return ZERO (no function/method named cherry_pick)

If ANY grep returns matches, fix them before claiming completion.
  </action>
  <verify>
    Run: `python -m pytest tests/test_compile_records.py -v` -- ALL tests pass.
    Run: `python -m pytest tests/ -x -q --timeout=300` -- ALL 1057+ tests pass (plus new ones).
    Run: `grep -rn "CompressionRow\|CompressionSourceRow\|CompressionResultRow\|CompressionRepository\|SqliteCompressionRepository\|compression_repo\|CherryPickResult\|CherryPickIssue\|CherryPickError" src/ tests/` -- ZERO matches.
  </verify>
  <done>
    Compile record tests pass. Full test suite passes with zero regressions. Zero references to old compression tables, old cherry-pick types, or old compression_repo anywhere in source or tests. Phase 13 is complete.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_compile_records.py -v` -- ALL pass
2. `python -m pytest tests/ -x -q --timeout=300` -- ALL 1057+ tests pass (zero regressions)
3. `grep -rn "CompressionRow\|CompressionSourceRow\|CompressionResultRow" src/ tests/` -- ZERO matches
4. `grep -rn "CompressionRepository\|SqliteCompressionRepository" src/ tests/` -- ZERO matches
5. `grep -rn "compression_repo" src/ tests/` -- ZERO matches
6. `grep -rn "CherryPickResult\|CherryPickIssue\|CherryPickError" src/ tests/` -- ZERO matches
7. `grep -rn "cherry_pick" src/tract/tract.py src/tract/operations/rebase.py` -- ZERO matches
8. Compile records created by generate() but NOT by manual compile()
</verification>

<success_criteria>
1. CompileRecordRow + CompileEffectiveRow persist what was compiled (SC-3, PROV-02)
2. chat()/generate() automatically create compile records (SC-3)
3. Manual compile() does NOT create compile records
4. Full test suite passes with zero regressions
5. Zero backward compatibility artifacts in entire codebase (SC-8)
6. All 8 Phase 13 success criteria verified
</success_criteria>

<output>
After completion, create `.planning/phases/13-unified-operation-events-compile-records/13-03-SUMMARY.md`
</output>
