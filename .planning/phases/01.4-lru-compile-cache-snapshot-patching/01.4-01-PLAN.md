---
phase: 01.4-lru-compile-cache-snapshot-patching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/protocols.py
  - src/tract/tract.py
  - src/tract/models/config.py
  - tests/test_tract.py
autonomous: true

must_haves:
  truths:
    - "Multiple compile snapshots cached simultaneously via LRU; switching HEAD to a previously-compiled position is a cache hit (O(1))"
    - "Incremental APPEND still works: new commit whose parent matches cached snapshot extends it in O(1)"
    - "EDIT commits patch the cached snapshot in-memory (find message by commit hash, replace, re-aggregate, recount tokens) with zero DB re-reads"
    - "Annotate with SKIP patches the cached snapshot by removing the target message and re-aggregating; un-skip falls back to full recompile"
    - "batch() clears entire LRU cache; crash loses cache; DB is always source of truth"
    - "verify_cache=True on Tract.open() cross-checks every cache hit/patch against a full recompile"
  artifacts:
    - path: "src/tract/protocols.py"
      provides: "CompileSnapshot with commit_hashes field"
      contains: "commit_hashes: tuple[str, ...]"
    - path: "src/tract/tract.py"
      provides: "LRU cache, EDIT patching, annotate patching, verify_cache"
      contains: "_snapshot_cache"
    - path: "tests/test_tract.py"
      provides: "Tests for LRU, EDIT patching, annotate patching, oracle verification"
      min_lines: 30
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/protocols.py"
      via: "CompileSnapshot.commit_hashes for EDIT patching lookup"
      pattern: "snapshot\\.commit_hashes"
    - from: "src/tract/tract.py"
      to: "src/tract/engine/compiler.py"
      via: "_aggregate_messages() reused for re-aggregation after patch"
      pattern: "_compiler\\._aggregate_messages"
    - from: "src/tract/tract.py"
      to: "collections.OrderedDict"
      via: "LRU cache backing store"
      pattern: "OrderedDict"
---

<objective>
Replace the single-snapshot compile cache with an LRU cache keyed by head_hash, and upgrade EDIT/annotate handling from full cache invalidation to in-memory snapshot patching.

Purpose: Checkout, reset, and future branch switching get cache hits instead of full recompiles. EDIT commits avoid expensive DB re-reads by patching the cached snapshot in-memory. This is a purely internal performance refactor -- no public API changes, no schema changes, no new dependencies.

Output: Modified `protocols.py` (CompileSnapshot gains commit_hashes field), modified `tract.py` (LRU cache + patching methods + verify_cache flag), modified `config.py` (cache_maxsize on TractConfig), new tests in `test_tract.py`.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.4-lru-compile-cache-snapshot-patching/01.4-RESEARCH.md
@.planning/phases/01.1-compile-cache-token-tracking/01.1-01-SUMMARY.md
@.planning/phases/01.3-hyperparameter-config-storage/01.3-01-SUMMARY.md
@src/tract/protocols.py
@src/tract/tract.py
@src/tract/engine/compiler.py
@src/tract/models/config.py
@tests/test_tract.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: LRU cache infrastructure + CompileSnapshot extension</name>
  <files>
    src/tract/protocols.py
    src/tract/models/config.py
    src/tract/tract.py
  </files>
  <action>
**1. Extend CompileSnapshot in `src/tract/protocols.py`:**

Add a `commit_hashes: tuple[str, ...] = ()` field to the `CompileSnapshot` frozen dataclass. This field is parallel to `raw_messages` -- position `i` in `commit_hashes` is the commit hash that produced `raw_messages[i]`. Place it after `generation_configs` (last field with a default). This enables EDIT patching to find which message to replace by commit hash.

**2. Add `compile_cache_maxsize` to TractConfig in `src/tract/models/config.py`:**

Add `compile_cache_maxsize: int = 8` field to `TractConfig`. This controls the LRU cache capacity. Place it after `default_branch`.

**3. Replace single snapshot with LRU cache in `src/tract/tract.py`:**

3a. Add `from collections import OrderedDict` at the top of the file.

3b. In `__init__()`:
- Remove `self._compile_snapshot: CompileSnapshot | None = None`
- Add `self._snapshot_cache: OrderedDict[str, CompileSnapshot] = OrderedDict()`
- Add `self._snapshot_cache_maxsize: int = config.compile_cache_maxsize`
- Add `self._verify_cache: bool = False` (will be set by open/from_components)

3c. Add `verify_cache: bool = False` parameter to `Tract.open()` and `Tract.from_components()`. Pass it through to `__init__` by adding a `verify_cache` parameter to `__init__()` and storing it as `self._verify_cache`.

3d. Add three private LRU cache helper methods:
```python
def _cache_get(self, head_hash: str) -> CompileSnapshot | None:
    if head_hash not in self._snapshot_cache:
        return None
    self._snapshot_cache.move_to_end(head_hash)
    return self._snapshot_cache[head_hash]

def _cache_put(self, head_hash: str, snapshot: CompileSnapshot) -> None:
    if head_hash in self._snapshot_cache:
        self._snapshot_cache.move_to_end(head_hash)
    self._snapshot_cache[head_hash] = snapshot
    while len(self._snapshot_cache) > self._snapshot_cache_maxsize:
        self._snapshot_cache.popitem(last=False)

def _cache_clear(self) -> None:
    self._snapshot_cache.clear()
```

3e. Update `compile()`:
- Replace `if self._compile_snapshot is not None and self._compile_snapshot.head_hash == current_head:` with `cached = self._cache_get(current_head)` then `if cached is not None:`.
- On cache hit: `result = self._snapshot_to_compiled(cached)`. If `self._verify_cache`, also do a full recompile and assert messages and token_count match (AssertionError with descriptive message if mismatch).
- On cache miss: full compile, then `snapshot = self._build_snapshot_from_compiled(current_head, result)` and `if snapshot is not None: self._cache_put(current_head, snapshot)`.

3f. Update `commit()` for APPEND path:
- Change the condition from `self._compile_snapshot is not None` to use `_cache_get` to find the parent's snapshot (the snapshot whose head_hash equals the PARENT of the new commit, i.e., `commit_info.parent_hash`). The new commit's parent_hash is the previous HEAD.
- Actually, the simpler correct approach: the snapshot for the PREVIOUS head (before this commit) should be used as the base. Before `self._session.commit()`, capture `prev_head = self.head`. After committing, for the APPEND path: `parent_snapshot = self._cache_get(prev_head)`. If found and compiler is DefaultContextCompiler, call `_extend_snapshot_for_append(info, parent_snapshot)` which now stores the result under the NEW head_hash via `_cache_put`. If not found, do nothing (next compile() will build from scratch).
- For non-APPEND (EDIT) path: do NOT invalidate the whole cache. Instead, attempt EDIT patching (Task 2 will implement `_patch_snapshot_for_edit`). For now in Task 1, keep the invalidation as `self._cache_clear()` for EDIT -- Task 2 will replace this with patching.

3g. Update `annotate()`:
- Replace `self._compile_snapshot = None` with `self._cache_clear()`. Task 2 will replace this with patching.

3h. Update `batch()`:
- Replace `self._compile_snapshot = None` with `self._cache_clear()`.

3i. Update `record_usage()`:
- Replace all references to `self._compile_snapshot` with `self._cache_get(target_hash)` / `self._cache_put(target_hash, updated_snapshot)`.
- When creating updated snapshot, use `dataclasses.replace()` (add `from dataclasses import replace` import). Pattern: `updated = replace(snapshot, token_count=usage.prompt_tokens, token_source=token_source)` then `self._cache_put(target_hash, updated)`.

3j. Update `_build_snapshot_from_compiled()`:
- Add `commit_hashes=()` to the CompileSnapshot construction. For a full-compile snapshot, commit_hashes are unknown from the CompiledContext alone. We need to extract them from the compiler. The approach: after the full compile in `compile()`, if compiler is DefaultContextCompiler, walk the chain again to get commit hashes. However, this is expensive. **Better approach**: Modify `_build_snapshot_from_compiled` to accept an optional `commit_hashes` parameter. When called from `compile()` with a full compile result, pass `commit_hashes=()` (unknown). When the snapshot is populated by incremental APPEND, commit_hashes are built up incrementally. When EDIT patching needs commit_hashes and they are empty, fall back to full recompile. This is safe because: (a) the first compile is always a full compile with commit_hashes=(), (b) subsequent APPENDs extend commit_hashes, (c) if the snapshot has empty commit_hashes when EDIT patching is needed, we fall back to full recompile which repopulates everything.

Actually, the cleaner approach from the research: populate `commit_hashes` during full compile. After the `self._compiler.compile()` call in `compile()`, walk the chain to extract the ordered hashes. This can reuse the compiler's `_walk_chain` and `_build_effective_commits` methods. Pattern:

```python
def _build_snapshot_from_compiled(self, head_hash, result, effective_commit_hashes=None):
    ...
    return CompileSnapshot(
        ...,
        commit_hashes=tuple(effective_commit_hashes) if effective_commit_hashes else (),
    )
```

In `compile()`, after a full compile cache miss:
```python
if isinstance(self._compiler, DefaultContextCompiler):
    commits = self._compiler._walk_chain(current_head)
    edit_map = self._compiler._build_edit_map(commits)
    priority_map = self._compiler._build_priority_map(commits)
    effective = self._compiler._build_effective_commits(commits, edit_map, priority_map)
    effective_hashes = [c.commit_hash for c in effective]
    snapshot = self._build_snapshot_from_compiled(current_head, result, effective_hashes)
else:
    snapshot = self._build_snapshot_from_compiled(current_head, result)
```

3k. Update `_extend_snapshot_for_append()`:
- Change signature to accept `parent_snapshot` as a parameter instead of reading `self._compile_snapshot`.
- Add `commit_info.commit_hash` to the `commit_hashes` tuple: `new_commit_hashes = parent_snapshot.commit_hashes + (commit_info.commit_hash,)`.
- Store result via `self._cache_put(commit_info.commit_hash, new_snapshot)` instead of assigning to `self._compile_snapshot`.
- The new snapshot's head_hash is `commit_info.commit_hash`.

**Important: Do NOT use `self._compile_snapshot` anywhere in tract.py after these changes. All snapshot access goes through `_cache_get`/`_cache_put`/`_cache_clear`.**
  </action>
  <verify>
Run `cd "C:\Users\jinwi\programming_files_NEW\Trace" && .venv/Scripts/python -m pytest tests/ -x -q` -- all 250 existing tests must pass with zero regressions. The LRU cache should be transparent to existing behavior.
  </verify>
  <done>
- `self._compile_snapshot` replaced by `self._snapshot_cache: OrderedDict` across all of tract.py
- CompileSnapshot has `commit_hashes: tuple[str, ...]` field
- TractConfig has `compile_cache_maxsize: int = 8`
- `verify_cache` parameter on Tract.open() and Tract.from_components()
- All 250 existing tests pass with no regressions
  </done>
</task>

<task type="auto">
  <name>Task 2: EDIT/annotate snapshot patching + oracle tests</name>
  <files>
    src/tract/tract.py
    tests/test_tract.py
  </files>
  <action>
**1. Implement `_patch_snapshot_for_edit()` in `src/tract/tract.py`:**

```python
def _patch_snapshot_for_edit(
    self,
    parent_snapshot: CompileSnapshot,
    new_head_hash: str,
    edit_commit_info: CommitInfo,
) -> CompileSnapshot | None:
    """Patch a cached snapshot for an EDIT commit in-memory.

    Finds the message corresponding to the edited target (via response_to),
    replaces it with the new message, re-aggregates, and recounts tokens.
    Returns None if patching is not possible (missing commit_hashes, target
    not found), signaling caller to fall back to full recompile.
    """
```

Logic:
- If `parent_snapshot.commit_hashes` is empty, return None (fall back to full recompile).
- `target_hash = edit_commit_info.response_to`. If None, return None.
- Find `target_idx` by iterating `parent_snapshot.commit_hashes` for `target_hash`. If not found, return None.
- Get the edit commit row: `edit_row = self._commit_repo.get(edit_commit_info.commit_hash)`. If None, return None.
- Build new message: `assert isinstance(self._compiler, DefaultContextCompiler)` then `new_message = self._compiler.build_message_for_commit(edit_row)`.
- Build new raw_messages: copy parent's raw_messages as list, replace at `target_idx` with `new_message`, convert back to tuple.
- Build new generation_configs: copy as list. If `edit_row.generation_config_json is not None`, replace at `target_idx`. Else keep original (edit-inherits-original rule from Phase 1.3).
- Re-aggregate: `new_aggregated = self._compiler._aggregate_messages(list(new_raw))`.
- Recount tokens using `self._token_counter.count_messages(...)` on new_aggregated (same pattern as `_extend_snapshot_for_append`).
- Return new CompileSnapshot with: `head_hash=new_head_hash`, updated raw_messages, aggregated_messages, token_count, token_source, `effective_hashes=parent_snapshot.effective_hashes | {new_head_hash}`, `commit_count=parent_snapshot.commit_count` (same -- EDIT replaces, doesn't add), `commit_hashes=parent_snapshot.commit_hashes` (positions unchanged -- the original commit hash stays in the mapping because the EDIT replaces the message at that position).

**2. Implement `_patch_snapshot_for_annotate()` in `src/tract/tract.py`:**

```python
def _patch_snapshot_for_annotate(
    self,
    snapshot: CompileSnapshot,
    target_hash: str,
    new_priority: Priority,
) -> CompileSnapshot | None:
    """Patch a cached snapshot for an annotation change.

    SKIP: remove the target's message from raw_messages.
    NORMAL/PINNED on already-included commit: no change needed.
    NORMAL/PINNED on previously-SKIP commit: return None (full recompile).
    """
```

Logic:
- If `snapshot.commit_hashes` is empty, return None (full recompile).
- Find `target_idx` in `snapshot.commit_hashes`.
- If `new_priority == Priority.SKIP`:
  - If `target_idx is None`: commit already not in snapshot, return snapshot unchanged (already correct).
  - Remove message at `target_idx` from raw_messages, commit_hashes, generation_configs.
  - Re-aggregate the remaining messages.
  - Recount tokens.
  - Return new CompileSnapshot with updated fields, `commit_count = parent.commit_count - 1`.
- Else (NORMAL or PINNED):
  - If `target_idx is not None`: commit already included, priority change doesn't affect compilation output. Return snapshot unchanged.
  - If `target_idx is None`: commit was skipped, now needs to be included but we don't have the message content. Return None (full recompile).

**3. Wire EDIT patching into `commit()` in `src/tract/tract.py`:**

Replace the EDIT path (currently `self._cache_clear()` from Task 1) with:

```python
# For EDIT commits: attempt snapshot patching
if operation == CommitOperation.EDIT and isinstance(self._compiler, DefaultContextCompiler):
    parent_snapshot = self._cache_get(prev_head) if prev_head else None
    if parent_snapshot is not None:
        patched = self._patch_snapshot_for_edit(parent_snapshot, info.commit_hash, info)
        if patched is not None:
            self._cache_put(info.commit_hash, patched)
            # Keep parent snapshot in cache (useful for checkout back)
        else:
            pass  # Next compile() will build from scratch
    # Do NOT clear cache -- other entries may still be valid
```

Note: Do NOT call `self._cache_clear()` for EDIT. Other LRU entries for different HEAD positions remain valid. Only the current HEAD's snapshot needs updating, which is handled by the patching.

**4. Wire annotate patching into `annotate()` in `src/tract/tract.py`:**

Replace `self._cache_clear()` with:

```python
if isinstance(self._compiler, DefaultContextCompiler):
    current_head = self.head
    if current_head:
        snapshot = self._cache_get(current_head)
        if snapshot is not None:
            patched = self._patch_snapshot_for_annotate(snapshot, target_hash, priority)
            if patched is not None:
                self._cache_put(current_head, patched)
            else:
                self._cache_clear()  # Un-skip: need full recompile
        # Other cache entries for different HEADs remain valid
else:
    self._cache_clear()
```

Wait -- annotations don't change HEAD, so the patched snapshot goes back under the SAME head_hash. This means `_cache_put(current_head, patched)` replaces the old entry for that HEAD.

**5. Add verify_cache oracle logic to `compile()` in `src/tract/tract.py`:**

After the cache hit path returns a result, if `self._verify_cache` is True, do a full recompile and assert:
```python
if self._verify_cache:
    fresh = self._compiler.compile(self._tract_id, current_head)
    assert result.messages == fresh.messages, (
        f"Cache message mismatch: cached {len(result.messages)} msgs, "
        f"fresh {len(fresh.messages)} msgs. "
        f"Cached: {[m.content[:50] for m in result.messages]}, "
        f"Fresh: {[m.content[:50] for m in fresh.messages]}"
    )
    assert result.token_count == fresh.token_count, (
        f"Cache token mismatch: cached {result.token_count}, "
        f"fresh {fresh.token_count}"
    )
```

**6. Write tests in `tests/test_tract.py`:**

Add a new test class `TestLRUCompileCacheAndPatching` with the following tests:

```python
class TestLRUCompileCacheAndPatching:
    """Tests for LRU compile cache, EDIT patching, annotate patching, and oracle verification."""

    def test_lru_cache_hit_after_recompile_at_same_head(self, tract):
        """Two compile() calls at same HEAD: second is cache hit."""
        tract.commit(InstructionContent(text="hello"))
        r1 = tract.compile()
        r2 = tract.compile()
        assert r1.messages == r2.messages
        assert r1.token_count == r2.token_count

    def test_lru_multiple_heads_cached(self):
        """After compiling at different HEADs, switching back is a cache hit."""
        # This simulates future checkout/reset behavior.
        # We can test by: commit A, compile, commit B, compile,
        # then use internal _cache_get to verify A's snapshot is retained.
        with Tract.open() as t:
            c1 = t.commit(InstructionContent(text="first"))
            head_after_c1 = t.head
            t.compile()  # Cache snapshot for head_after_c1
            c2 = t.commit(DialogueContent(role="user", text="second"))
            head_after_c2 = t.head
            t.compile()  # Cache snapshot for head_after_c2
            # Both should be in cache
            assert t._cache_get(head_after_c1) is not None
            assert t._cache_get(head_after_c2) is not None

    def test_lru_eviction_at_maxsize(self):
        """Cache evicts LRU entry when maxsize is exceeded."""
        config = TractConfig(compile_cache_maxsize=2)
        with Tract.open(config=config) as t:
            # Create 3 different HEADs and compile each
            c1 = t.commit(InstructionContent(text="a"))
            h1 = t.head
            t.compile()
            c2 = t.commit(DialogueContent(role="user", text="b"))
            h2 = t.head
            t.compile()
            c3 = t.commit(DialogueContent(role="assistant", text="c"))
            h3 = t.head
            t.compile()
            # h1 should be evicted (maxsize=2, h2 and h3 remain)
            assert t._cache_get(h1) is None
            assert t._cache_get(h2) is not None
            assert t._cache_get(h3) is not None

    def test_append_incremental_still_works(self, tract):
        """APPEND commits still extend the cached snapshot incrementally."""
        tract.commit(InstructionContent(text="system"))
        r1 = tract.compile()
        tract.commit(DialogueContent(role="user", text="hello"))
        r2 = tract.compile()
        assert r2.commit_count == 2
        assert len(r2.messages) == 2

    def test_edit_patching_matches_full_recompile(self):
        """EDIT patching produces identical result to full recompile (oracle test)."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(InstructionContent(text="System prompt"))
            c2 = t.commit(DialogueContent(role="user", text="Original question"))
            c3 = t.commit(DialogueContent(role="assistant", text="Original answer"))
            t.compile()  # Populate cache with commit_hashes

            # EDIT c2
            t.commit(
                DialogueContent(role="user", text="Edited question"),
                operation=CommitOperation.EDIT,
                response_to=c2.commit_hash,
            )
            # With verify_cache=True, compile() asserts patched == fresh
            result = t.compile()
            assert any("Edited question" in m.content for m in result.messages)
            assert not any("Original question" in m.content for m in result.messages)

    def test_edit_patching_preserves_generation_config(self):
        """EDIT without generation_config preserves original's config (edit-inherits-original)."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(
                InstructionContent(text="System"),
                generation_config={"temperature": 0.7},
            )
            t.compile()  # Populate cache

            t.commit(
                InstructionContent(text="Edited system"),
                operation=CommitOperation.EDIT,
                response_to=c1.commit_hash,
            )
            result = t.compile()
            # Original config should be preserved
            assert result.generation_configs[0] == {"temperature": 0.7}

    def test_edit_patching_with_new_config(self):
        """EDIT with its own generation_config replaces the original's config."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(
                InstructionContent(text="System"),
                generation_config={"temperature": 0.7},
            )
            t.compile()

            t.commit(
                InstructionContent(text="Edited system"),
                operation=CommitOperation.EDIT,
                response_to=c1.commit_hash,
                generation_config={"temperature": 0.9},
            )
            result = t.compile()
            assert result.generation_configs[0] == {"temperature": 0.9}

    def test_annotate_skip_patching_matches_full_recompile(self):
        """Annotating with SKIP patches snapshot by removing message."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(InstructionContent(text="System"))
            c2 = t.commit(DialogueContent(role="user", text="Hello"))
            c3 = t.commit(DialogueContent(role="assistant", text="Hi"))
            t.compile()  # Populate cache

            t.annotate(c2.commit_hash, Priority.SKIP)
            # verify_cache=True will assert patched == fresh
            result = t.compile()
            assert result.commit_count == 2  # c1 and c3 only
            assert not any("Hello" in m.content for m in result.messages)

    def test_annotate_unskip_falls_back_to_full_recompile(self):
        """Un-skipping a commit falls back to full recompile (not patched)."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(InstructionContent(text="System"))
            c2 = t.commit(DialogueContent(role="user", text="Hello"))
            t.annotate(c2.commit_hash, Priority.SKIP)
            t.compile()  # Cache without c2

            # Un-skip: should trigger full recompile
            t.annotate(c2.commit_hash, Priority.NORMAL)
            result = t.compile()
            assert result.commit_count == 2
            assert any("Hello" in m.content for m in result.messages)

    def test_batch_clears_entire_cache(self):
        """batch() clears the entire LRU cache."""
        with Tract.open() as t:
            t.commit(InstructionContent(text="first"))
            t.compile()
            assert len(t._snapshot_cache) == 1
            with t.batch():
                t.commit(DialogueContent(role="user", text="batched"))
            assert len(t._snapshot_cache) == 0

    def test_record_usage_updates_correct_cache_entry(self):
        """record_usage() updates token count in the LRU cache entry."""
        with Tract.open() as t:
            t.commit(InstructionContent(text="hello"))
            compiled = t.compile()
            original_tokens = compiled.token_count

            updated = t.record_usage({"prompt_tokens": 42, "completion_tokens": 10, "total_tokens": 52})
            assert updated.token_count == 42
            assert "api:" in updated.token_source

            # Verify cache entry was updated
            cached = t._cache_get(t.head)
            assert cached is not None
            assert cached.token_count == 42

    def test_edit_patching_same_role_reaggregation(self):
        """EDIT that changes role boundaries triggers correct re-aggregation."""
        with Tract.open(verify_cache=True) as t:
            c1 = t.commit(DialogueContent(role="user", text="Q1"))
            c2 = t.commit(DialogueContent(role="assistant", text="A1"))
            c3 = t.commit(DialogueContent(role="user", text="Q2"))
            t.compile()

            # Edit c2 to be role="user" -- now c1, c2, c3 are all "user" and should aggregate
            t.commit(
                DialogueContent(role="user", text="Actually also a question"),
                operation=CommitOperation.EDIT,
                response_to=c2.commit_hash,
            )
            result = t.compile()
            # All three should aggregate into one user message
            assert len(result.messages) == 1
            assert result.messages[0].role == "user"

    def test_verify_cache_flag_off_by_default(self):
        """verify_cache defaults to False and doesn't affect behavior."""
        with Tract.open() as t:
            assert t._verify_cache is False
            t.commit(InstructionContent(text="test"))
            t.compile()  # Should work without oracle check

    def test_commit_hashes_populated_after_full_compile(self):
        """After a full compile, snapshot has commit_hashes populated."""
        with Tract.open() as t:
            c1 = t.commit(InstructionContent(text="a"))
            c2 = t.commit(DialogueContent(role="user", text="b"))
            t.compile()
            snapshot = t._cache_get(t.head)
            assert snapshot is not None
            assert len(snapshot.commit_hashes) == 2
            assert snapshot.commit_hashes[0] == c1.commit_hash
            assert snapshot.commit_hashes[1] == c2.commit_hash

    def test_commit_hashes_extend_on_append(self):
        """Incremental APPEND extends commit_hashes."""
        with Tract.open() as t:
            c1 = t.commit(InstructionContent(text="a"))
            t.compile()
            c2 = t.commit(DialogueContent(role="user", text="b"))
            # After APPEND, snapshot should have both hashes
            snapshot = t._cache_get(t.head)
            assert snapshot is not None
            assert len(snapshot.commit_hashes) == 2
            assert snapshot.commit_hashes[1] == c2.commit_hash
```

Ensure all test names start with `test_` and the class is in the `TestLRUCompileCacheAndPatching` class. Import `CommitOperation`, `Priority`, `TractConfig`, `InstructionContent`, `DialogueContent` at top of file (they should already be imported).
  </action>
  <verify>
Run `cd "C:\Users\jinwi\programming_files_NEW\Trace" && .venv/Scripts/python -m pytest tests/ -x -q` -- all tests must pass (250 existing + ~16 new = ~266 total). Specifically:
- `python -m pytest tests/test_tract.py::TestLRUCompileCacheAndPatching -v` -- all new tests pass
- All oracle tests with `verify_cache=True` pass (meaning patched results are identical to full recompile)
  </verify>
  <done>
- EDIT commits patch snapshot in-memory: find message by commit hash, replace, re-aggregate, recount tokens -- zero DB re-reads
- Annotate SKIP removes target message from snapshot and re-aggregates; un-skip falls back to full recompile
- verify_cache=True triggers oracle assertion on every cache hit
- All 5 roadmap success criteria are met:
  1. Multiple snapshots cached via LRU; switching HEAD is a cache hit
  2. Incremental APPEND still works (O(1) extend)
  3. EDIT uses snapshot patching (zero DB re-reads)
  4. Annotate SKIP uses snapshot patching
  5. batch() clears entire LRU cache; DB is source of truth
- All ~266 tests pass (250 existing + ~16 new)
  </done>
</task>

</tasks>

<verification>
1. `cd "C:\Users\jinwi\programming_files_NEW\Trace" && .venv/Scripts/python -m pytest tests/ -x -q` -- full test suite passes
2. `grep -r "_compile_snapshot" src/tract/tract.py` returns zero matches (fully replaced by LRU cache)
3. `grep "commit_hashes" src/tract/protocols.py` confirms the new field exists on CompileSnapshot
4. `grep "_snapshot_cache" src/tract/tract.py` confirms LRU cache is present
5. `grep "verify_cache" src/tract/tract.py` confirms oracle flag is wired
6. All oracle tests (`verify_cache=True`) pass, proving cache consistency
</verification>

<success_criteria>
1. Multiple compile snapshots cached simultaneously via LRU; switching HEAD to a previously-compiled position is a cache hit (O(1))
2. Incremental APPEND still works: new commit's parent matches cached snapshot -> O(1) extend
3. EDIT commits use snapshot patching: cached snapshot is copied, edited message replaced in-memory, re-aggregated -- zero DB re-reads
4. Annotate (priority change to SKIP) uses snapshot patching instead of full invalidation
5. batch() remains full cache clear; crash loses cache; DB is always source of truth
6. All existing 250 tests pass with zero regressions
7. New tests cover LRU eviction, EDIT patching, annotate patching, oracle verification, and commit_hashes tracking
</success_criteria>

<output>
After completion, create `.planning/phases/01.4-lru-compile-cache-snapshot-patching/01.4-01-SUMMARY.md`
</output>
