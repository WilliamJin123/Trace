---
phase: 01.3-hyperparameter-config-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/models/commit.py
  - src/tract/storage/schema.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/engine/commit.py
  - src/tract/engine/compiler.py
  - src/tract/protocols.py
  - src/tract/tract.py
  - tests/test_tract.py
  - tests/test_storage/test_repositories.py
  - tests/test_engine/test_commit.py
  - tests/test_engine/test_compiler.py
autonomous: true

must_haves:
  truths:
    - "User can attach a generation config dict to any commit via tract.commit(..., generation_config={...}) and retrieve it from CommitInfo.generation_config"
    - "generation_config is stored as a nullable JSON blob in SQLite, accepting any provider's parameters without migration"
    - "CompiledContext.generation_configs is a list of dicts parallel to effective commits (pre-aggregation), preserving the 1:1 commit-to-config mapping through compilation"
    - "When an EDIT commit has no generation_config, the compiled output inherits the original commit's generation_config (not empty dict)"
    - "User can query commits by config values via tract.query_by_config(field, operator, value) using SQL-side json_extract()"
    - "Incremental compile cache (CompileSnapshot) carries generation_configs through snapshot-to-compiled conversion, with copy-on-output to prevent cache corruption"
    - "generation_config is NOT included in commit hash computation (same content + different config = same content_hash)"
  artifacts:
    - path: "src/tract/models/commit.py"
      provides: "generation_config field on CommitInfo"
      contains: "generation_config"
    - path: "src/tract/storage/schema.py"
      provides: "generation_config_json column on CommitRow"
      contains: "generation_config_json"
    - path: "src/tract/storage/repositories.py"
      provides: "get_by_config abstract method on CommitRepository"
      contains: "get_by_config"
    - path: "src/tract/storage/sqlite.py"
      provides: "get_by_config implementation using func.json_extract"
      contains: "json_extract"
    - path: "src/tract/engine/commit.py"
      provides: "generation_config param threaded through create_commit and _row_to_info"
      contains: "generation_config"
    - path: "src/tract/protocols.py"
      provides: "generation_configs field on CompiledContext and CompileSnapshot"
      contains: "generation_configs"
    - path: "src/tract/tract.py"
      provides: "generation_config param on commit(), query_by_config() method, copy-on-output in _snapshot_to_compiled"
      contains: "query_by_config"
    - path: "tests/test_tract.py"
      provides: "Integration tests covering all 5 success criteria for generation config"
      contains: "TestGenerationConfig"
    - path: "tests/test_storage/test_repositories.py"
      provides: "Unit tests for get_by_config SQL-side JSON querying"
      contains: "test_get_by_config"
    - path: "tests/test_engine/test_commit.py"
      provides: "Unit tests for generation_config threading through CommitEngine"
      contains: "generation_config"
    - path: "tests/test_engine/test_compiler.py"
      provides: "Unit tests for generation_config collection during compile and edit fallback"
      contains: "generation_config"
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/engine/commit.py"
      via: "generation_config param passed through commit()"
      pattern: "generation_config"
    - from: "src/tract/engine/commit.py"
      to: "src/tract/storage/schema.py"
      via: "generation_config_json stored on CommitRow"
      pattern: "generation_config_json"
    - from: "src/tract/tract.py"
      to: "src/tract/protocols.py"
      via: "CompileSnapshot.generation_configs carried through compile cache"
      pattern: "generation_configs"
    - from: "src/tract/tract.py"
      to: "src/tract/storage/sqlite.py"
      via: "query_by_config delegates to SqliteCommitRepository.get_by_config"
      pattern: "get_by_config"
---

<objective>
Add generation config (LLM hyperparameter) storage to the commit model, threading it through the full commit/compile/query pipeline.

Purpose: Every commit can now store the exact LLM generation config (temperature, top_p, model, etc.) used at call time, giving full provenance for how each piece of context was generated. This enables downstream patterns like exploration/exploitation branching where hyperparams are tuned per-branch and results compared.

Design decisions:
- generation_config is set at commit time ONLY (immutable once written, like all commit data)
- record_usage() is NOT extended with generation_config — the config is always known before the API call
- Copy-on-output pattern in _snapshot_to_compiled prevents cache corruption from mutable dicts
- When an EDIT commit has no generation_config, the original commit's config is inherited
- No index on generation_config_json column (known limitation; SQLite generated column indexes can be added later)

Output: A `generation_config: Optional[dict]` field on CommitInfo, `generation_config_json` column on CommitRow, generation_configs list on CompiledContext/CompileSnapshot, `query_by_config()` on Tract, and comprehensive tests at integration and unit levels.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.3-hyperparameter-config-storage/01.3-RESEARCH.md
@src/tract/models/commit.py
@src/tract/storage/schema.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/engine/commit.py
@src/tract/engine/compiler.py
@src/tract/protocols.py
@src/tract/tract.py
@src/tract/__init__.py
@tests/test_tract.py
@tests/test_storage/test_repositories.py
@tests/test_engine/test_commit.py
@tests/test_engine/test_compiler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generation_config field to data model, storage schema, engine, and compiler</name>
  <files>
    src/tract/models/commit.py
    src/tract/storage/schema.py
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    src/tract/engine/commit.py
    src/tract/engine/compiler.py
    src/tract/protocols.py
  </files>
  <action>
    **1a. Add generation_config to CommitInfo (models/commit.py):**

    Add a new optional field after `metadata`:

    ```python
    generation_config: Optional[dict] = None
    ```

    This field holds the LLM generation configuration (temperature, top_p, model, etc.) as a flexible dict. It is immutable once committed.

    **1b. Add generation_config_json column to CommitRow (storage/schema.py):**

    Add a new nullable JSON column after `metadata_json`:

    ```python
    generation_config_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)
    ```

    This follows the exact same pattern as `metadata_json`.

    **1c. Add get_by_config abstract method to CommitRepository (storage/repositories.py):**

    Add a new abstract method to the `CommitRepository` ABC:

    ```python
    @abstractmethod
    def get_by_config(
        self, tract_id: str, json_path: str, operator: str, value: object
    ) -> Sequence[CommitRow]:
        """Get commits where generation_config matches the given condition.

        Args:
            tract_id: Tract identifier to scope the query.
            json_path: JSON field name (e.g., "temperature", "model").
            operator: Comparison operator ("=", "!=", ">", "<", ">=", "<=").
            value: Value to compare against.

        Returns:
            Matching commits ordered by created_at ascending.
        """
        ...
    ```

    **1d. Implement get_by_config in SqliteCommitRepository (storage/sqlite.py):**

    Add the concrete implementation using `func.json_extract()`:

    ```python
    def get_by_config(
        self, tract_id: str, json_path: str, operator: str, value: object
    ) -> Sequence[CommitRow]:
        extracted = func.json_extract(
            CommitRow.generation_config_json, f'$.{json_path}'
        )
        ops = {
            "=": lambda e, v: e == v,
            "!=": lambda e, v: e != v,
            ">": lambda e, v: e > v,
            "<": lambda e, v: e < v,
            ">=": lambda e, v: e >= v,
            "<=": lambda e, v: e <= v,
        }
        if operator not in ops:
            raise ValueError(f"Unsupported operator: {operator}. Use one of: {list(ops.keys())}")
        condition = ops[operator](extracted, value)
        stmt = (
            select(CommitRow)
            .where(CommitRow.tract_id == tract_id, condition)
            .order_by(CommitRow.created_at)
        )
        return list(self._session.execute(stmt).scalars().all())
    ```

    Note: No index on generation_config_json — queries use full table scan filtered by tract_id. This is acceptable at Phase 1 scale; SQLite generated column indexes can be added in a future phase if query performance becomes a concern.

    **1e. Thread generation_config through CommitEngine (engine/commit.py):**

    - Add `generation_config: dict | None = None` parameter to `create_commit()` method signature (after `metadata`).
    - Pass it to the CommitRow constructor as `generation_config_json=generation_config`.
    - Include it in the returned CommitInfo: `generation_config=generation_config`.
    - Update `_row_to_info()` to map `row.generation_config_json` to `generation_config`.
    - Do NOT include generation_config in the commit hash computation (it is NOT part of the hash, same decision as metadata).

    The updated `create_commit()` signature:
    ```python
    def create_commit(
        self,
        content: BaseModel,
        operation: CommitOperation = CommitOperation.APPEND,
        message: str | None = None,
        edit_target: str | None = None,
        metadata: dict | None = None,
        generation_config: dict | None = None,
    ) -> CommitInfo:
    ```

    In the CommitRow construction (step 10), add:
    ```python
    generation_config_json=generation_config,
    ```

    In the returned CommitInfo (step 13), add:
    ```python
    generation_config=generation_config,
    ```

    In `_row_to_info()`, add:
    ```python
    generation_config=row.generation_config_json,
    ```

    **1f. Add generation_configs to CompiledContext and CompileSnapshot (protocols.py):**

    Add a new field to `CompiledContext`:
    ```python
    generation_configs: list[dict] = field(default_factory=list)
    ```

    This is a list parallel to the effective commits (pre-aggregation). Each entry is the generation_config dict for the corresponding effective commit, or an empty dict `{}` if none was set.

    Add a new field to `CompileSnapshot`:
    ```python
    generation_configs: tuple[dict, ...] = ()
    ```

    Note: The dicts inside the tuple are mutable (unlike Message which is a frozen dataclass). Cache safety is ensured by copy-on-output in `_snapshot_to_compiled()` (see Task 2c).

    **1g. Collect generation_configs during compilation (engine/compiler.py):**

    In `DefaultContextCompiler.compile()`, after building the effective commit list (Step 4), collect generation configs from the effective commits. Between Step 4 and Step 5 in the `compile()` method:

    ```python
    # Step 4b: Collect generation configs for effective commits
    generation_configs: list[dict] = []
    for c in effective_commits:
        # If this commit was edited, prefer the edit's config;
        # fall back to the original commit's config if the edit has none.
        edit_commit = edit_map.get(c.commit_hash)
        if edit_commit is not None and edit_commit.generation_config_json is not None:
            config = edit_commit.generation_config_json
        else:
            config = c.generation_config_json or {}
        generation_configs.append(config)
    ```

    This two-step fallback ensures that:
    - When an edit specifies a generation_config, it is used (the edit produced new content with different params).
    - When an edit does NOT specify a generation_config, the original commit's config is preserved (the edit only changed content, not the generation context).

    Pass `generation_configs` into the returned CompiledContext:
    ```python
    return CompiledContext(
        messages=messages,
        token_count=token_count,
        commit_count=len(effective_commits),
        token_source=token_source,
        generation_configs=generation_configs,
    )
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/ -v --tb=short`
    All existing 220 tests should pass (no behavioral change for existing code paths where generation_config is None).
    Verify the new column is created: `python -c "from tract.storage.schema import CommitRow; print(CommitRow.__table__.columns.keys())"` -- should include `generation_config_json`.
  </verify>
  <done>
    CommitInfo has generation_config field. CommitRow has generation_config_json column. CommitEngine threads the param through create_commit and _row_to_info. CommitRepository has get_by_config ABC and SQLite implementation. CompiledContext and CompileSnapshot have generation_configs field. DefaultContextCompiler collects configs during compile with edit-inherits-original fallback. All 220 existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generation_config through Tract facade</name>
  <files>
    src/tract/tract.py
  </files>
  <action>
    **2a. Add generation_config to Tract.commit():**

    Add `generation_config: dict | None = None` kwarg to the `commit()` method signature:

    ```python
    def commit(
        self,
        content: BaseModel | dict,
        *,
        operation: CommitOperation = CommitOperation.APPEND,
        message: str | None = None,
        edit_target: str | None = None,
        metadata: dict | None = None,
        generation_config: dict | None = None,
    ) -> CommitInfo:
    ```

    Pass it through to `self._commit_engine.create_commit(... generation_config=generation_config)`.

    **2b. Update _extend_snapshot_for_append to carry generation_configs:**

    In `_extend_snapshot_for_append()`, after getting the commit_row, get its generation_config:

    ```python
    new_config = commit_row.generation_config_json or {}
    ```

    When constructing the new CompileSnapshot, extend generation_configs:
    ```python
    self._compile_snapshot = CompileSnapshot(
        head_hash=commit_info.commit_hash,
        raw_messages=new_raw,
        aggregated_messages=new_aggregated,
        effective_hashes=snapshot.effective_hashes | {commit_info.commit_hash},
        commit_count=snapshot.commit_count + 1,
        token_count=new_token_count,
        token_source=self._tiktoken_source(),
        generation_configs=snapshot.generation_configs + (new_config,),
    )
    ```

    **2c. Update _snapshot_to_compiled with copy-on-output:**

    Use `dict(c)` to shallow-copy each config dict, preventing user mutations of the returned CompiledContext from corrupting the cached snapshot:

    ```python
    def _snapshot_to_compiled(self, snapshot: CompileSnapshot) -> CompiledContext:
        return CompiledContext(
            messages=list(snapshot.aggregated_messages),
            token_count=snapshot.token_count,
            commit_count=snapshot.commit_count,
            token_source=snapshot.token_source,
            generation_configs=[dict(c) for c in snapshot.generation_configs],
        )
    ```

    This is necessary because CompileSnapshot stores `tuple[dict, ...]` where the dicts are mutable (unlike `tuple[Message, ...]` where Message is a frozen dataclass). The shallow copy is sufficient because generation configs are flat key-value pairs (temperature, model, top_p — no deeply nested structures).

    **2d. Update _build_snapshot_from_compiled to capture generation_configs:**

    ```python
    def _build_snapshot_from_compiled(
        self, head_hash: str, result: CompiledContext
    ) -> CompileSnapshot | None:
        if not isinstance(self._compiler, DefaultContextCompiler):
            return None
        return CompileSnapshot(
            head_hash=head_hash,
            raw_messages=tuple(result.messages),
            aggregated_messages=tuple(result.messages),
            effective_hashes=frozenset(),
            commit_count=result.commit_count,
            token_count=result.token_count,
            token_source=result.token_source,
            generation_configs=tuple(result.generation_configs),
        )
    ```

    **2e. Update record_usage() to preserve generation_configs in snapshot:**

    record_usage() does NOT accept a generation_config parameter (config is set at commit time only). However, it must preserve generation_configs when reconstructing the snapshot with updated token counts.

    In the snapshot reconstruction block inside record_usage(), add the generation_configs field:

    ```python
    self._compile_snapshot = CompileSnapshot(
        head_hash=self._compile_snapshot.head_hash,
        raw_messages=self._compile_snapshot.raw_messages,
        aggregated_messages=self._compile_snapshot.aggregated_messages,
        effective_hashes=self._compile_snapshot.effective_hashes,
        commit_count=self._compile_snapshot.commit_count,
        token_count=usage.prompt_tokens,
        token_source=token_source,
        generation_configs=self._compile_snapshot.generation_configs,
    )
    ```

    **2f. Add query_by_config() method to Tract:**

    Add a new public method:

    ```python
    def query_by_config(
        self,
        field: str,
        operator: str,
        value: object,
    ) -> list[CommitInfo]:
        """Query commits by generation config values.

        Uses SQL-side json_extract() for efficient filtering.

        Args:
            field: JSON field name in the generation config (e.g., "temperature", "model").
            operator: Comparison operator ("=", "!=", ">", "<", ">=", "<=").
            value: Value to compare against.

        Returns:
            List of :class:`CommitInfo` matching the condition, ordered by created_at.
        """
        rows = self._commit_repo.get_by_config(
            self._tract_id, field, operator, value
        )
        return [self._commit_engine._row_to_info(row) for row in rows]
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/ -v --tb=short`
    All existing 220 tests should pass (no behavioral change).
  </verify>
  <done>
    Tract.commit() accepts generation_config kwarg and passes it through to storage. Tract.compile() returns generation_configs in CompiledContext with copy-on-output. record_usage() preserves generation_configs in snapshot without accepting new param. Tract.query_by_config() provides SQL-side JSON querying. Incremental compile cache carries generation_configs. All 220 existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write integration and unit tests</name>
  <files>
    tests/test_tract.py
    tests/test_storage/test_repositories.py
    tests/test_engine/test_commit.py
    tests/test_engine/test_compiler.py
  </files>
  <action>
    **3a. Integration tests in tests/test_tract.py:**

    Add a new test class `TestGenerationConfig` at the end of the test file:

    ```python
    class TestGenerationConfig:
        """Phase 1.3: Hyperparameter config storage tests."""

        # SC1: Attach and retrieve generation_config
        def test_commit_with_generation_config(self, tract: Tract):
            config = {"model": "gpt-4o", "temperature": 0.7, "top_p": 0.95}
            info = tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=config,
            )
            assert info.generation_config == config
            # Retrieve via get_commit
            fetched = tract.get_commit(info.commit_hash)
            assert fetched is not None
            assert fetched.generation_config == config

        def test_commit_without_generation_config(self, tract: Tract):
            info = tract.commit(DialogueContent(role="user", text="Hi"))
            assert info.generation_config is None
            fetched = tract.get_commit(info.commit_hash)
            assert fetched is not None
            assert fetched.generation_config is None

        def test_generation_config_in_log(self, tract: Tract):
            config = {"temperature": 0.9}
            tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=config,
            )
            entries = tract.log(limit=1)
            assert entries[0].generation_config == config

        # SC2: Flexible schema -- any provider params work
        def test_generation_config_arbitrary_provider_params(self, tract: Tract):
            openai_config = {"model": "gpt-4o", "temperature": 0.7, "frequency_penalty": 0.5}
            anthropic_config = {"model": "claude-3-opus", "top_k": 40, "temperature": 0.3}
            meta_config = {"model": "llama-3", "repetition_penalty": 1.2, "min_p": 0.05}

            c1 = tract.commit(DialogueContent(role="user", text="a"), generation_config=openai_config)
            c2 = tract.commit(DialogueContent(role="user", text="b"), generation_config=anthropic_config)
            c3 = tract.commit(DialogueContent(role="user", text="c"), generation_config=meta_config)

            assert c1.generation_config == openai_config
            assert c2.generation_config == anthropic_config
            assert c3.generation_config == meta_config

        # SC3: generation_configs preserved through compile
        def test_compile_exposes_generation_configs(self, tract: Tract):
            config1 = {"temperature": 0.5}
            config2 = {"temperature": 0.9}
            tract.commit(InstructionContent(text="System"), generation_config=config1)
            tract.commit(DialogueContent(role="user", text="Hi"), generation_config=config2)
            result = tract.compile()
            assert len(result.generation_configs) == 2
            assert result.generation_configs[0] == config1
            assert result.generation_configs[1] == config2

        def test_compile_empty_config_for_commits_without_config(self, tract: Tract):
            tract.commit(InstructionContent(text="System"))
            tract.commit(DialogueContent(role="user", text="Hi"), generation_config={"temperature": 0.7})
            result = tract.compile()
            assert result.generation_configs[0] == {}
            assert result.generation_configs[1] == {"temperature": 0.7}

        def test_compile_incremental_carries_generation_configs(self, tract: Tract):
            config1 = {"temperature": 0.3}
            config2 = {"temperature": 0.7}
            tract.commit(InstructionContent(text="System"), generation_config=config1)
            result1 = tract.compile()
            assert result1.generation_configs == [config1]

            tract.commit(DialogueContent(role="user", text="Hi"), generation_config=config2)
            result2 = tract.compile()
            assert result2.generation_configs == [config1, config2]

        def test_compile_edit_preserves_generation_config_of_replacement(self, tract: Tract):
            config_orig = {"temperature": 0.5}
            config_edit = {"temperature": 0.9}
            c1 = tract.commit(
                DialogueContent(role="user", text="original"),
                generation_config=config_orig,
            )
            tract.commit(
                DialogueContent(role="user", text="edited"),
                operation=CommitOperation.EDIT,
                edit_target=c1.commit_hash,
                generation_config=config_edit,
            )
            result = tract.compile()
            # The effective commit's config comes from the edit replacement
            assert result.generation_configs[0] == config_edit

        def test_compile_edit_without_config_inherits_original(self, tract: Tract):
            """When an EDIT commit has no generation_config, the original's config is inherited."""
            config_orig = {"temperature": 0.7, "model": "gpt-4o"}
            c1 = tract.commit(
                DialogueContent(role="user", text="original"),
                generation_config=config_orig,
            )
            tract.commit(
                DialogueContent(role="user", text="edited text only"),
                operation=CommitOperation.EDIT,
                edit_target=c1.commit_hash,
                # No generation_config on the edit
            )
            result = tract.compile()
            # Original config inherited since edit didn't specify one
            assert result.generation_configs[0] == config_orig

        # SC4: generation_config NOT in commit hash
        def test_generation_config_not_in_hash(self, tract: Tract):
            """Same content with different generation_configs should produce
            the same content_hash (different commit_hash due to timestamp/parent)."""
            c1 = tract.commit(
                DialogueContent(role="user", text="identical"),
                generation_config={"temperature": 0.1},
            )
            c2 = tract.commit(
                DialogueContent(role="user", text="identical"),
                generation_config={"temperature": 0.9},
            )
            # content_hash should be the same (same content)
            assert c1.content_hash == c2.content_hash
            # commit_hash differs because of parent_hash and timestamp, not config
            assert c1.commit_hash != c2.commit_hash

        # SC5: Query by config values
        def test_query_by_config_equality(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"model": "gpt-4o", "temperature": 0.5},
            )
            tract.commit(
                DialogueContent(role="user", text="b"),
                generation_config={"model": "claude-3", "temperature": 0.9},
            )
            tract.commit(
                DialogueContent(role="user", text="c"),
                generation_config={"model": "gpt-4o", "temperature": 0.7},
            )
            results = tract.query_by_config("model", "=", "gpt-4o")
            assert len(results) == 2
            assert all(r.generation_config["model"] == "gpt-4o" for r in results)

        def test_query_by_config_greater_than(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"temperature": 0.3},
            )
            tract.commit(
                DialogueContent(role="user", text="b"),
                generation_config={"temperature": 0.8},
            )
            tract.commit(
                DialogueContent(role="user", text="c"),
                generation_config={"temperature": 1.0},
            )
            results = tract.query_by_config("temperature", ">", 0.5)
            assert len(results) == 2
            assert all(r.generation_config["temperature"] > 0.5 for r in results)

        def test_query_by_config_no_matches(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"temperature": 0.3},
            )
            results = tract.query_by_config("temperature", ">", 0.9)
            assert len(results) == 0

        def test_query_by_config_invalid_operator(self, tract: Tract):
            with pytest.raises(ValueError, match="Unsupported operator"):
                tract.query_by_config("temperature", "LIKE", 0.5)

        def test_query_by_config_commits_without_config_excluded(self, tract: Tract):
            tract.commit(DialogueContent(role="user", text="no config"))
            tract.commit(
                DialogueContent(role="user", text="with config"),
                generation_config={"temperature": 0.7},
            )
            results = tract.query_by_config("temperature", "=", 0.7)
            assert len(results) == 1

        # Cache safety: copy-on-output prevents corruption
        def test_compile_cache_not_corrupted_by_mutation(self, tract: Tract):
            """Mutating generation_configs on a returned CompiledContext
            should not affect subsequent compile() results."""
            config = {"temperature": 0.5}
            tract.commit(DialogueContent(role="user", text="Hi"), generation_config=config)
            result1 = tract.compile()
            # Mutate the returned dict
            result1.generation_configs[0]["temperature"] = 999
            # Compile again -- should return clean copy from cache
            result2 = tract.compile()
            assert result2.generation_configs[0] == config
    ```

    **3b. Unit tests in tests/test_storage/test_repositories.py:**

    Add a new test class `TestSqliteCommitRepositoryGetByConfig`:

    ```python
    class TestSqliteCommitRepositoryGetByConfig:
        """Unit tests for SqliteCommitRepository.get_by_config()."""

        def test_get_by_config_equality(self, commit_repo, session, sample_tract_id):
            # Create commits with generation_config_json, query by equality
            ...

        def test_get_by_config_greater_than(self, commit_repo, session, sample_tract_id):
            # Query by numeric comparison
            ...

        def test_get_by_config_no_matches(self, commit_repo, session, sample_tract_id):
            # Query returns empty list when no matches
            ...

        def test_get_by_config_invalid_operator_raises(self, commit_repo, session, sample_tract_id):
            # ValueError on unsupported operator
            ...

        def test_get_by_config_null_config_excluded(self, commit_repo, session, sample_tract_id):
            # Commits with NULL generation_config_json are not returned
            ...
    ```

    **3c. Unit tests in tests/test_engine/test_commit.py:**

    Add tests to the existing `TestCreateCommit` class (or a new `TestGenerationConfig` class):

    ```python
    def test_create_commit_with_generation_config(self, commit_engine, ...):
        """generation_config is stored on CommitRow and returned in CommitInfo."""
        ...

    def test_create_commit_without_generation_config(self, commit_engine, ...):
        """generation_config defaults to None when not provided."""
        ...

    def test_row_to_info_maps_generation_config(self, commit_engine, ...):
        """_row_to_info correctly maps generation_config_json to generation_config."""
        ...
    ```

    **3d. Unit tests in tests/test_engine/test_compiler.py:**

    Add a new test class `TestGenerationConfigCollection`:

    ```python
    class TestGenerationConfigCollection:
        """Unit tests for generation_config collection during compile."""

        def test_compile_collects_generation_configs(self, compiler, ...):
            """generation_configs list parallel to effective commits."""
            ...

        def test_compile_empty_config_for_no_config_commit(self, compiler, ...):
            """Commits without generation_config get {} in the list."""
            ...

        def test_edit_with_config_uses_edit_config(self, compiler, ...):
            """When edit has generation_config, it is used."""
            ...

        def test_edit_without_config_inherits_original(self, compiler, ...):
            """When edit has no generation_config, original commit's config is inherited."""
            ...

        def test_skip_priority_commit_excluded_from_configs(self, compiler, ...):
            """SKIP commits don't appear in generation_configs list."""
            ...
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/test_tract.py::TestGenerationConfig -v`
    All new integration tests pass.

    Run: `python -m pytest tests/test_storage/test_repositories.py -v -k "get_by_config"`
    All new repository unit tests pass.

    Run: `python -m pytest tests/test_engine/ -v -k "generation_config"`
    All new engine unit tests pass.

    Run: `python -m pytest tests/ -v`
    All 220 existing tests pass + ~25 new tests pass (no regressions).
  </verify>
  <done>
    Integration tests cover all 5 success criteria plus cache safety. Unit tests cover get_by_config at repository layer, generation_config threading at commit engine layer, and config collection with edit fallback at compiler layer. All tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:

```bash
python -m pytest tests/ -v
```

Expected: All existing 220 tests pass + ~25 new generation config tests pass.

Verify all 5 success criteria:

1. **SC1** (attach and retrieve): `test_commit_with_generation_config`, `test_commit_without_generation_config`, `test_generation_config_in_log`
2. **SC2** (flexible schema): `test_generation_config_arbitrary_provider_params`
3. **SC3** (preserved through compile): `test_compile_exposes_generation_configs`, `test_compile_empty_config_for_commits_without_config`, `test_compile_incremental_carries_generation_configs`, `test_compile_edit_preserves_generation_config_of_replacement`, `test_compile_edit_without_config_inherits_original`
4. **SC4** (hash safety): `test_generation_config_not_in_hash`
5. **SC5** (queryable): `test_query_by_config_equality`, `test_query_by_config_greater_than`, `test_query_by_config_no_matches`, `test_query_by_config_invalid_operator`, `test_query_by_config_commits_without_config_excluded`
6. **Cache safety**: `test_compile_cache_not_corrupted_by_mutation`
</verification>

<success_criteria>
1. `generation_config: Optional[dict]` field on CommitInfo, populated from `generation_config_json` JSON column on CommitRow
2. `tract.commit(..., generation_config={...})` stores the config immutably and returns it in CommitInfo
3. `CompiledContext.generation_configs` is a list parallel to effective commits, populated by both full compile and incremental cache paths
4. Edit fallback: when an EDIT has no generation_config, the original commit's config is inherited in CompiledContext
5. `tract.query_by_config(field, operator, value)` returns matching CommitInfo list using SQL-side json_extract()
6. generation_config is NOT part of commit hash computation (content_hash identical for same content regardless of config)
7. Copy-on-output in _snapshot_to_compiled prevents cache corruption from mutable dicts
8. All 220 existing tests pass with no regressions
9. ~25 new tests covering all 5 phase success criteria at integration and unit levels
</success_criteria>

<output>
After completion, create `.planning/phases/01.3-hyperparameter-config-storage/01.3-01-SUMMARY.md`
</output>
