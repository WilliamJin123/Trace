---
phase: 01-foundations
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/trace/repo.py
  - src/trace/__init__.py
  - tests/test_repo.py
autonomous: true

must_haves:
  truths:
    - "User can initialize a trace via Repo.open() with a file path or in-memory"
    - "User can commit content via repo.commit() with any of the 7 content types"
    - "User can commit with edit/delete operations via repo.commit() with operation parameter"
    - "User can annotate commits with priority (pin/skip) via repo.annotate()"
    - "User can materialize the current context via repo.materialize() and get structured messages"
    - "User can get commit info by hash via repo.get_commit()"
    - "User can set a custom tokenizer or custom materializer via Repo constructor or config"
    - "All public API is importable from the trace package root"
  artifacts:
    - path: "src/trace/repo.py"
      provides: "Repo class -- the primary SDK entry point"
      exports: ["Repo"]
      min_lines: 100
    - path: "src/trace/__init__.py"
      provides: "Public API exports"
      exports: ["Repo", "ContentPayload", "InstructionContent", "DialogueContent", "CommitOperation", "Priority", "Message", "MaterializedContext"]
    - path: "tests/test_repo.py"
      provides: "Integration tests through public API"
      min_lines: 150
  key_links:
    - from: "src/trace/repo.py"
      to: "src/trace/engine/commit.py"
      via: "Repo delegates commit operations to CommitEngine"
      pattern: "CommitEngine"
    - from: "src/trace/repo.py"
      to: "src/trace/engine/materialize.py"
      via: "Repo delegates materialize to DefaultMaterializer"
      pattern: "DefaultMaterializer"
    - from: "src/trace/repo.py"
      to: "src/trace/storage/engine.py"
      via: "Repo.open() creates SQLAlchemy engine and session"
      pattern: "create_trace_engine|create_session_factory"
    - from: "src/trace/__init__.py"
      to: "src/trace/repo.py"
      via: "Package root re-exports Repo class"
      pattern: "from trace.repo import Repo"
---

<objective>
Build the Repo class -- the public SDK entry point that ties together storage, commit engine, and materializer into a clean, user-facing API. This is what users actually interact with: `Repo.open()`, `repo.commit()`, `repo.materialize()`. Also finalize the package's `__init__.py` exports and write comprehensive integration tests through the public API only.

Purpose: The Repo class is the product. Everything in Plans 01 and 02 was infrastructure. This plan wraps it into the API users will use. Integration tests here validate the entire stack end-to-end.
Output: Working Repo class with full public API, clean package exports, and integration tests that verify all 5 Phase 1 success criteria.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\PROJECT.md
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\ROADMAP.md
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\phases\01-foundations\01-CONTEXT.md
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\phases\01-foundations\01-RESEARCH.md
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\phases\01-foundations\01-01-SUMMARY.md
@C:\Users\jinwi\programming_files_NEW\Trace\.planning\phases\01-foundations\01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Repo class (public SDK entry point)</name>
  <files>
    src/trace/repo.py
    src/trace/__init__.py
  </files>
  <action>
    **1. Repo class (repo.py):**

    ```python
    class Repo:
        """Primary entry point for Trace -- git-like version control for LLM context."""
    ```

    **Class method -- Repo.open():**
    `@classmethod open(cls, path: str = ":memory:", *, repo_id: str | None = None, config: RepoConfig | None = None, tokenizer: TokenCounter | None = None, materializer: Materializer | None = None) -> Repo`

    - If path is ":memory:", create in-memory SQLite. Otherwise, create file-backed SQLite at that path.
    - If repo_id not provided, generate a UUID4 string
    - Create engine via create_trace_engine(path)
    - Create session factory and session
    - Initialize all 4 Sqlite*Repository instances
    - Create TiktokenCounter (or use provided tokenizer)
    - Create CommitEngine with repos, counter, repo_id, budget config
    - Create DefaultMaterializer (or use provided materializer) with repos, counter
    - If path is a file and the DB already exists, re-use existing data (the schema.create_all is idempotent)
    - Create initial "main" branch ref if it does not exist
    - Return Repo instance

    **Constructor __init__:**
    Store all internal components as private attributes:
    - self._engine, self._session, self._commit_engine, self._materializer
    - self._repo_id, self._config
    - self._commit_repo, self._blob_repo, self._ref_repo, self._annotation_repo
    - self._token_counter

    **Public properties:**
    - `repo_id: str` -- the repo identifier
    - `head: str | None` -- current HEAD commit hash (via ref_repo.get_head)
    - `config: RepoConfig` -- the repo config

    **Public methods:**

    `commit(content, *, operation=CommitOperation.APPEND, message=None, reply_to=None, metadata=None) -> CommitInfo`:
    - content can be a Pydantic content model instance OR a dict (auto-validated via validate_content)
    - Delegates to self._commit_engine.create_commit(...)
    - Returns CommitInfo

    `materialize(*, as_of=None, include_edit_annotations=False) -> MaterializedContext`:
    - Gets current HEAD
    - If HEAD is None, return empty MaterializedContext (no commits yet)
    - Delegates to self._materializer.materialize(self._repo_id, self.head, as_of=as_of, include_edit_annotations=include_edit_annotations)
    - Returns MaterializedContext

    `get_commit(commit_hash: str) -> CommitInfo | None`:
    - Delegates to self._commit_engine.get_commit(commit_hash)

    `annotate(target_hash: str, priority: Priority, *, reason: str | None = None) -> PriorityAnnotation`:
    - Delegates to self._commit_engine.annotate(target_hash, priority, reason)

    `get_annotations(target_hash: str) -> list[PriorityAnnotation]`:
    - Returns annotation history for a commit

    `close()`:
    - Close session and dispose engine
    - Set a _closed flag to prevent further operations

    `__enter__` / `__exit__`:
    - Context manager support. __exit__ calls close().

    `__repr__`:
    - `Repo(repo_id='{self._repo_id}', head='{self.head}')`

    **Important design notes:**
    - The Repo class is a thin facade. All logic lives in CommitEngine and DefaultMaterializer.
    - Content can be passed as dict OR Pydantic model. If dict, validate via validate_content() before passing to engine.
    - Session management: Repo owns one session for its lifetime. The session commits after each operation (auto-commit pattern). This is simple and correct for single-user SDK usage.
    - Thread safety: NOT thread-safe in v1. Document this. Each thread should open its own Repo.

    **2. Package exports (__init__.py):**
    Update src/trace/__init__.py to export the complete public API:

    ```python
    """Trace: Git-like version control for LLM context windows."""
    from trace._version import __version__

    # Core entry point
    from trace.repo import Repo

    # Content types
    from trace.models.content import (
        ContentPayload,
        InstructionContent,
        DialogueContent,
        ToolIOContent,
        ReasoningContent,
        ArtifactContent,
        OutputContent,
        FreeformContent,
        register_content_type,
        validate_content,
        BUILTIN_TYPE_HINTS,
        ContentTypeHints,
    )

    # Commit and annotation types
    from trace.models.commit import CommitInfo, CommitOperation
    from trace.models.annotations import Priority, PriorityAnnotation

    # Configuration
    from trace.models.config import RepoConfig, TokenBudgetConfig, BudgetAction

    # Protocols and output types
    from trace.protocols import (
        TokenCounter,
        Materializer,
        Message,
        MaterializedContext,
        TokenUsage,
    )

    # Exceptions
    from trace.exceptions import (
        TraceError,
        CommitNotFoundError,
        BlobNotFoundError,
        ValidationError,
        BudgetExceededError,
        EditTargetError,
    )

    __all__ = [
        "__version__",
        "Repo",
        # Content types
        "ContentPayload", "InstructionContent", "DialogueContent",
        "ToolIOContent", "ReasoningContent", "ArtifactContent",
        "OutputContent", "FreeformContent",
        "register_content_type", "validate_content",
        "BUILTIN_TYPE_HINTS", "ContentTypeHints",
        # Commit types
        "CommitInfo", "CommitOperation",
        # Annotations
        "Priority", "PriorityAnnotation",
        # Config
        "RepoConfig", "TokenBudgetConfig", "BudgetAction",
        # Protocols
        "TokenCounter", "Materializer", "Message", "MaterializedContext", "TokenUsage",
        # Exceptions
        "TraceError", "CommitNotFoundError", "BlobNotFoundError",
        "ValidationError", "BudgetExceededError", "EditTargetError",
    ]
    ```
  </action>
  <verify>
    Run: `cd C:\Users\jinwi\programming_files_NEW\Trace && python -c "from trace import Repo, InstructionContent, CommitOperation, Priority, Message; r = Repo.open(); print(f'Repo opened: {r}'); r.close(); print('All imports and basic open/close work')"'`
    Repo.open() creates an in-memory trace, returns Repo instance, close() works.
  </verify>
  <done>
    - Repo.open() creates working in-memory or file-backed traces
    - repo.commit() accepts Pydantic models and dicts
    - repo.materialize() returns structured message list
    - repo.annotate() changes commit priorities
    - Context manager support works
    - All public API importable from `trace` package root
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests through public API (all Phase 1 success criteria)</name>
  <files>
    tests/test_repo.py
  </files>
  <action>
    Write comprehensive integration tests that use ONLY the public API (Repo class). These tests validate all 5 Phase 1 success criteria end-to-end.

    **Test structure -- organize by success criterion:**

    **SC1: User can initialize a new trace via Repo.open() and it persists to SQLite storage**
    - `test_open_in_memory`: Repo.open() with no args creates in-memory trace
    - `test_open_file_backed`: Repo.open("test.db") creates file, close, re-open reads same data (use tmp_path fixture)
    - `test_open_with_custom_repo_id`: repo_id is preserved
    - `test_open_as_context_manager`: `with Repo.open() as repo:` works
    - `test_persistence_across_reopen`: commit content, close, re-open with same path, materialize returns same content

    **SC2: User can commit context with message, timestamp, and type (append/edit/pin) and retrieve it by hash**
    - `test_commit_append`: commit returns CommitInfo with hash, message, timestamp, token_count
    - `test_commit_edit`: commit with operation=EDIT and reply_to replaces original in materialization
    - `test_commit_delete`: commit with operation=DELETE excludes target from materialization
    - `test_get_commit_by_hash`: repo.get_commit(hash) returns the commit
    - `test_get_commit_nonexistent`: repo.get_commit("fake") returns None
    - `test_commit_chain`: 3 commits, each has correct parent_hash
    - `test_commit_cumulative_tokens`: cumulative_tokens increases with each commit

    **SC3: User can commit structured content (all types) and structure is preserved through materialization**
    - `test_instruction_content`: commit InstructionContent, materialize, check role=system
    - `test_dialogue_content_user`: commit DialogueContent(role="user"), materialize, check role=user
    - `test_dialogue_content_assistant`: commit DialogueContent(role="assistant"), check role=assistant
    - `test_tool_io_content`: commit ToolIOContent, materialize, check role=tool and content includes tool_name
    - `test_reasoning_content`: commit ReasoningContent, check role=assistant
    - `test_artifact_content`: commit ArtifactContent, check content preserved
    - `test_output_content`: commit OutputContent, check content preserved
    - `test_freeform_content`: commit FreeformContent(payload={"custom": "data"}), check preserved
    - `test_content_from_dict`: commit content as dict (not Pydantic model), verify it validates and works
    - `test_mixed_content_types`: commit instruction + dialogue + tool_io, materialize, verify correct roles and ordering

    **SC4: User can materialize using default or custom materializer**
    - `test_materialize_empty_repo`: materialize on fresh repo returns empty messages
    - `test_materialize_default`: basic commit + materialize returns messages
    - `test_materialize_edit_resolution`: original replaced by edit in output
    - `test_materialize_skip_annotation`: annotate commit with SKIP, materialize excludes it
    - `test_materialize_time_travel`: commit 3 items, materialize as_of 2nd commit's hash, only see first 2
    - `test_materialize_aggregation`: two consecutive user messages aggregate into one
    - `test_custom_materializer`: create a trivial custom Materializer class, pass to Repo.open(materializer=custom), verify it's used

    **SC5: Token counting with pluggable tokenizer**
    - `test_commit_has_token_count`: every CommitInfo has token_count > 0
    - `test_materialize_has_token_count`: MaterializedContext has token_count > 0
    - `test_cumulative_tokens_correct`: after 3 commits, last commit's cumulative equals sum of all three
    - `test_custom_tokenizer`: create a trivial TokenCounter that returns fixed values, pass to Repo.open(tokenizer=custom), verify counts use custom counter
    - `test_token_budget_warn`: set budget, exceed it, commit succeeds (warn mode)
    - `test_token_budget_reject`: set budget with REJECT, exceed it, raises BudgetExceededError

    **Edge cases:**
    - `test_edit_requires_reply_to`: edit without reply_to raises error
    - `test_edit_cannot_target_edit`: edit targeting another edit raises EditTargetError
    - `test_annotate_priority_changes`: annotate same commit multiple times, latest priority wins in materialization
    - `test_annotation_history`: get_annotations returns full history

    **Use pytest fixtures:**
    - `repo` fixture: `Repo.open()` with yield and close
    - `repo_with_commits` fixture: repo with 3 pre-committed items for tests that need existing data
    - Use `tmp_path` for file-backed persistence tests
  </action>
  <verify>
    Run: `cd C:\Users\jinwi\programming_files_NEW\Trace && python -m pytest tests/test_repo.py -v --tb=short`
    All integration tests pass.

    Run full suite: `python -m pytest tests/ -v --tb=short`
    ALL tests (models + storage + engine + integration) pass together.

    Run with coverage: `python -m pytest tests/ --cov=trace --cov-report=term-missing`
    Coverage should be 80%+.
  </verify>
  <done>
    - All 5 Phase 1 success criteria verified through public API tests
    - Repo.open() works in-memory and file-backed with persistence
    - All 7 content types commit and materialize correctly
    - Edit/delete operations work through public API
    - Priority annotations work (pin/skip/normal)
    - Time-travel materialization works
    - Custom tokenizer and custom materializer pluggable via Repo.open()
    - Token budget enforcement works (warn + reject)
    - 30+ integration tests passing
    - Overall test coverage 80%+
  </done>
</task>

</tasks>

<verification>
Run the complete test suite:
```bash
cd C:\Users\jinwi\programming_files_NEW\Trace && python -m pytest tests/ -v --tb=short
```

Run with coverage:
```bash
python -m pytest tests/ --cov=trace --cov-report=term-missing
```

Verify all 5 Phase 1 success criteria with a single end-to-end script:
```bash
python -c "
from trace import (
    Repo, InstructionContent, DialogueContent, ToolIOContent,
    CommitOperation, Priority, Message, MaterializedContext
)

# SC1: Initialize trace
repo = Repo.open()
print(f'SC1 PASS: Repo opened: {repo}')

# SC2: Commit with message, timestamp, type
c1 = repo.commit(InstructionContent(text='You are helpful.'), message='system')
c2 = repo.commit(DialogueContent(role='user', text='Hi'), message='greeting')
c3 = repo.commit(DialogueContent(role='assistant', text='Hello!'), message='reply')
assert repo.get_commit(c1.commit_hash) is not None
print(f'SC2 PASS: 3 commits created, retrievable by hash')

# SC3: Structured content preserved through materialization
result = repo.materialize()
assert len(result.messages) == 3
assert result.messages[0].role == 'system'
assert result.messages[1].role == 'user'
assert result.messages[2].role == 'assistant'
print(f'SC3 PASS: Materialized {len(result.messages)} messages with correct roles')

# SC4: Materialization works (default materializer tested above, custom tested in unit tests)
# Test edit resolution
c4 = repo.commit(
    InstructionContent(text='You are a coding assistant.'),
    operation=CommitOperation.EDIT,
    reply_to=c1.commit_hash,
    message='update system prompt'
)
result2 = repo.materialize()
assert 'coding assistant' in result2.messages[0].content
print(f'SC4 PASS: Edit resolution works in materialization')

# SC5: Token counts
assert c1.token_count > 0
assert c3.cumulative_tokens > c1.token_count
assert result.token_count > 0
print(f'SC5 PASS: Token counts present (commit: {c1.token_count}, cumulative: {c3.cumulative_tokens}, materialized: {result.token_count})')

repo.close()
print('ALL 5 SUCCESS CRITERIA VERIFIED')
"
```
</verification>

<success_criteria>
- Repo.open() creates working traces (in-memory and file-backed)
- All 7 content types work through repo.commit() and repo.materialize()
- Edit and delete operations work correctly through public API
- Priority annotations (pin/skip) affect materialization output
- Time-travel materialization works via as_of parameter
- Custom tokenizer pluggable via Repo.open(tokenizer=...)
- Custom materializer pluggable via Repo.open(materializer=...)
- Token budget enforcement works (warn and reject modes)
- File-backed traces persist across close/re-open
- All integration tests pass (30+ tests)
- Full test suite passes (all plans combined, 80%+ coverage)
- All 5 Phase 1 success criteria verified end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundations/01-03-SUMMARY.md`
</output>
