---
phase: 06-policy-engine
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/tract/policy/builtin/__init__.py
  - src/tract/policy/builtin/compress.py
  - src/tract/policy/builtin/pin.py
  - src/tract/policy/builtin/branch.py
  - src/tract/policy/builtin/rebase.py
  - src/tract/policy/__init__.py
  - src/tract/__init__.py
  - tests/test_policy_builtin.py
  - tests/test_policy_integration.py
autonomous: true

must_haves:
  truths:
    - "CompressPolicy fires when token usage exceeds configured threshold percentage of budget"
    - "CompressPolicy preserves pinned commits during compression"
    - "PinPolicy auto-pins InstructionContent and SessionContent commits on commit"
    - "PinPolicy respects manual overrides (does not re-pin commits user explicitly set to NORMAL/SKIP)"
    - "PinPolicy performs retroactive scan when first enabled"
    - "BranchPolicy detects content type switches and proposes branching"
    - "RebasePolicy detects stale branches and proposes archiving to archive/ prefix"
    - "All built-in policies have correct priority ordering (pin=100 < compress=200 < branch=300 < rebase=500)"
    - "Full end-to-end flow works: configure policies, commit content, trigger evaluation, verify actions executed"
    - "Policy config roundtrips through save/load for built-in policies"
  artifacts:
    - path: "src/tract/policy/builtin/compress.py"
      provides: "CompressPolicy with threshold-based auto-compress"
      contains: "class CompressPolicy"
    - path: "src/tract/policy/builtin/pin.py"
      provides: "PinPolicy with content-type-based auto-pin"
      contains: "class PinPolicy"
    - path: "src/tract/policy/builtin/branch.py"
      provides: "BranchPolicy with tangent detection heuristic"
      contains: "class BranchPolicy"
    - path: "src/tract/policy/builtin/rebase.py"
      provides: "RebasePolicy with stale branch archiving"
      contains: "class RebasePolicy"
    - path: "src/tract/policy/builtin/__init__.py"
      provides: "Public exports for built-in policies"
      contains: "CompressPolicy"
    - path: "tests/test_policy_builtin.py"
      provides: "Unit tests for each built-in policy"
      min_lines: 150
    - path: "tests/test_policy_integration.py"
      provides: "End-to-end integration tests for the full policy system"
      min_lines: 80
  key_links:
    - from: "src/tract/policy/builtin/compress.py"
      to: "src/tract/tract.py"
      via: "CompressPolicy.evaluate() reads tract.status() for token count"
      pattern: "tract\\.status\\(\\)"
    - from: "src/tract/policy/builtin/pin.py"
      to: "src/tract/tract.py"
      via: "PinPolicy.evaluate() reads tract.head and tract.get_commit()"
      pattern: "tract\\.get_commit"
    - from: "src/tract/policy/builtin/rebase.py"
      to: "src/tract/tract.py"
      via: "RebasePolicy.evaluate() reads tract.log() for staleness"
      pattern: "tract\\.log"
    - from: "tests/test_policy_integration.py"
      to: "src/tract/tract.py"
      via: "End-to-end: configure_policies -> commit -> compile -> verify policy actions"
      pattern: "configure_policies"
---

<objective>
Implement the four built-in policies (CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy) and comprehensive integration tests covering the full policy lifecycle from configuration through evaluation to execution.

Purpose: These are the concrete policy implementations that deliver the AUTO-01 through AUTO-06 requirements. Each policy is a focused subclass of Policy ABC that calls existing Tract operations via the evaluator. The integration tests prove the entire system works end-to-end.

Output: Four built-in policy implementations, updated exports, unit tests for each policy, and end-to-end integration tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-policy-engine/06-CONTEXT.md
@.planning/phases/06-policy-engine/06-RESEARCH.md
@.planning/phases/06-policy-engine/06-01-SUMMARY.md
@.planning/phases/06-policy-engine/06-02-SUMMARY.md
@src/tract/tract.py
@src/tract/policy/protocols.py
@src/tract/policy/evaluator.py
@src/tract/models/policy.py
@src/tract/models/content.py
@src/tract/models/annotations.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Built-in policies (CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy)</name>
  <files>
    src/tract/policy/builtin/__init__.py
    src/tract/policy/builtin/compress.py
    src/tract/policy/builtin/pin.py
    src/tract/policy/builtin/branch.py
    src/tract/policy/builtin/rebase.py
    src/tract/policy/__init__.py
    src/tract/__init__.py
  </files>
  <action>
Create the `src/tract/policy/builtin/` subpackage.

**builtin/compress.py** -- CompressPolicy:
- `from __future__ import annotations`, `if TYPE_CHECKING:` for Tract
- Subclass Policy ABC
- `name = "auto-compress"`, `priority = 200`, `trigger = "compile"`
- Constructor: `threshold: float = 0.9` (default 90% of budget per CONTEXT.md)
- `evaluate(self, tract)`:
  1. Get `tract.config.token_budget` -- if None or `max_tokens` is None, return None (no budget configured)
  2. Get `tract.status()` for current `token_count`
  3. If `token_count >= max_tokens * self._threshold`:
     - Return `PolicyAction(action_type="compress", params={"auto_commit": True, "content": None}, reason=f"Token usage {token_count}/{max_tokens} exceeds {self._threshold:.0%} threshold", autonomy="collaborative")`
  4. Else return None
- Add `to_config(self) -> dict` and `@classmethod from_config(cls, config: dict) -> CompressPolicy` for serialization roundtrip

**builtin/pin.py** -- PinPolicy:
- `name = "auto-pin"`, `priority = 100`, `trigger = "commit"`
- Constructor: `pin_types: set[str] | None = None` (default `{"instruction", "session"}`), `patterns: list[dict] | None = None` (default [])
- `evaluate(self, tract)`:
  1. Get `tract.head` -- if None, return None
  2. Get commit via `tract.get_commit(head)`
  3. Check if already pinned via `tract.get_annotations(head)` -- if latest annotation is PINNED, return None
  4. Check for manual override: if ANY annotation exists (user already made a choice), return None. This respects "manual overrides always win"
  5. Check content_type match: if `commit.content_type in self._pin_types`, return annotate action
  6. Check patterns: for each pattern in `self._patterns`, match against commit content_type + role + text (using `re.search` for regex patterns). Pattern format: `{"content_type": "dialogue", "role": "system", "text_pattern": "important.*context"}`
  7. If match found, return `PolicyAction(action_type="annotate", params={"target_hash": head, "priority": "pinned"}, reason=f"Auto-pinned: ...", autonomy="autonomous")` -- autonomous because pinning is low-risk
  8. Else return None
- Add `retroactive_scan(self, tract) -> list[str]` method:
  - Walk all commits via `tract.log(limit=1000)`
  - For each commit, apply the same matching logic as evaluate()
  - Skip commits that already have annotations (manual override protection)
  - Pin matching commits via `tract.annotate(hash, Priority.PINNED, reason="auto-pin retroactive scan")`
  - Return list of pinned commit hashes
- Add `to_config` / `from_config` for serialization

**builtin/branch.py** -- BranchPolicy:
- `name = "auto-branch"`, `priority = 300`, `trigger = "commit"`
- Constructor: `content_type_window: int = 5` (look at last N commits), `switch_threshold: int = 3` (minimum type switches to trigger)
- `evaluate(self, tract)`:
  1. If tract.current_branch is None (detached HEAD), return None
  2. Get recent commits: `tract.log(limit=self._content_type_window)`
  3. If fewer than 3 commits, return None (not enough history)
  4. Count content_type transitions: iterate consecutive pairs, count where type changes
  5. If transitions >= `self._switch_threshold`:
     - Generate branch name: `f"tangent/{tract.current_branch}/{datetime.now().strftime('%H%M%S')}"`
     - Return `PolicyAction(action_type="branch", params={"name": branch_name}, reason=f"Detected {transitions} content type switches in last {len(recent)} commits", autonomy="collaborative")`
  6. Else return None
- Add `to_config` / `from_config`

**builtin/rebase.py** -- RebasePolicy:
- `name = "auto-rebase"`, `priority = 500`, `trigger = "compile"`
- Constructor: `stale_days: int = 7`, `min_commits: int = 3`, `archive_prefix: str = "archive/"`
- `evaluate(self, tract)`:
  1. Get `tract.current_branch` -- if None or "main", return None (don't archive main or detached)
  2. If branch name already starts with archive_prefix, return None
  3. Get recent commits: `tract.log(limit=1)` for last activity time
  4. If no commits, return None
  5. Calculate age: `(now - last_commit_time).total_seconds() / 86400`
  6. Get commit count: `tract.log(limit=self._min_commits + 1)` -- if `len(commits) <= self._min_commits` AND `age_days >= self._stale_days`:
     - `archive_name = f"{self._archive_prefix}{current_branch}"`
     - Return `PolicyAction(action_type="archive", params={"source_branch": current_branch, "archive_name": archive_name}, reason=f"Branch '{current_branch}' stale ({age_days:.0f} days, {len(commits)} commits)", autonomy="collaborative")`
  7. Else return None
- Add `to_config` / `from_config`

**builtin/__init__.py** -- Re-export:
```python
from tract.policy.builtin.compress import CompressPolicy
from tract.policy.builtin.pin import PinPolicy
from tract.policy.builtin.branch import BranchPolicy
from tract.policy.builtin.rebase import RebasePolicy

__all__ = ["CompressPolicy", "PinPolicy", "BranchPolicy", "RebasePolicy"]
```

**policy/__init__.py** -- Update exports to include built-in policies:
```python
from tract.policy.protocols import Policy
from tract.policy.evaluator import PolicyEvaluator
from tract.policy.builtin import CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy

__all__ = [
    "Policy", "PolicyEvaluator",
    "CompressPolicy", "PinPolicy", "BranchPolicy", "RebasePolicy",
]
```

**__init__.py** -- Update tract's top-level exports:
- Add imports: `from tract.policy.builtin import CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy`
- Add to `__all__`: `"CompressPolicy"`, `"PinPolicy"`, `"BranchPolicy"`, `"RebasePolicy"`
  </action>
  <verify>
Run `python -c "from tract import CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy; print('OK')"` to confirm imports work. Run `python -c "from tract.policy.builtin.compress import CompressPolicy; p = CompressPolicy(); print(p.name, p.priority, p.trigger)"` to verify defaults.
  </verify>
  <done>
Four built-in policies exist with correct names, priorities, and triggers. CompressPolicy checks token budget threshold. PinPolicy matches content types and respects manual overrides. BranchPolicy detects content type switches. RebasePolicy detects stale branches. All have to_config/from_config for persistence. All exported from tract package.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for built-in policies and end-to-end integration tests</name>
  <files>
    tests/test_policy_builtin.py
    tests/test_policy_integration.py
  </files>
  <action>
**tests/test_policy_builtin.py** -- Unit tests for each built-in policy:

Use `Tract.open(":memory:")` with appropriate configs for each policy.

**CompressPolicy tests:**
1. `test_compress_policy_no_budget` -- no token budget configured, evaluate returns None
2. `test_compress_policy_below_threshold` -- token usage below 90%, returns None
3. `test_compress_policy_above_threshold` -- token usage above 90%, returns PolicyAction with action_type="compress"
4. `test_compress_policy_custom_threshold` -- custom threshold (e.g., 0.5) works
5. `test_compress_policy_properties` -- name="auto-compress", priority=200, trigger="compile"
6. `test_compress_policy_config_roundtrip` -- to_config/from_config preserves threshold

To set up threshold tests: create a Tract with `TractConfig(token_budget=TokenBudgetConfig(max_tokens=100))`, commit enough content to exceed 90 tokens, then evaluate. For "below threshold" tests, commit less content.

**PinPolicy tests:**
7. `test_pin_policy_pins_instruction_content` -- commit InstructionContent, evaluate returns annotate action
8. `test_pin_policy_pins_session_content` -- commit SessionContent, evaluate returns annotate action
9. `test_pin_policy_skips_dialogue` -- commit DialogueContent, returns None
10. `test_pin_policy_respects_manual_override` -- annotate commit as NORMAL first, then evaluate returns None
11. `test_pin_policy_skips_already_pinned` -- annotate as PINNED first, evaluate returns None
12. `test_pin_policy_custom_types` -- configure with custom pin_types={"dialogue"}, pins DialogueContent
13. `test_pin_policy_retroactive_scan` -- create multiple commits of various types, call retroactive_scan(), verify correct ones pinned
14. `test_pin_policy_retroactive_scan_respects_manual` -- manually annotate one commit, retroactive scan skips it
15. `test_pin_policy_properties` -- name="auto-pin", priority=100, trigger="commit"
16. `test_pin_policy_config_roundtrip` -- to_config/from_config preserves pin_types

**BranchPolicy tests:**
17. `test_branch_policy_no_tangent` -- uniform content types, returns None
18. `test_branch_policy_detects_tangent` -- rapid content type switching (dialogue->artifact->tool_io->dialogue->artifact), returns PolicyAction with action_type="branch"
19. `test_branch_policy_too_few_commits` -- fewer than 3 commits, returns None
20. `test_branch_policy_detached_head` -- detached HEAD returns None
21. `test_branch_policy_custom_threshold` -- custom switch_threshold works
22. `test_branch_policy_properties` -- name="auto-branch", priority=300, trigger="commit"

**RebasePolicy tests:**
23. `test_rebase_policy_main_branch_skipped` -- on main branch, returns None
24. `test_rebase_policy_active_branch_skipped` -- recent commits, returns None
25. `test_rebase_policy_stale_branch_detected` -- NOTE: This test is tricky because it requires time manipulation. Create a branch, commit with a backdated created_at (use the direct commit engine or mock datetime). Verify returns archive action. If datetime mocking is complex, create a simpler test: verify that a branch with 0 commits returns None (because log returns empty), and test the logic paths separately.
26. `test_rebase_policy_archive_prefix` -- custom archive_prefix works
27. `test_rebase_policy_already_archived_skipped` -- branch name starting with "archive/" returns None
28. `test_rebase_policy_properties` -- name="auto-rebase", priority=500, trigger="compile"

**tests/test_policy_integration.py** -- End-to-end integration tests:

1. `test_auto_pin_on_commit` -- configure PinPolicy (autonomous), commit InstructionContent, verify it gets auto-pinned (check annotations)
2. `test_auto_compress_on_compile` -- configure CompressPolicy with low threshold (0.5), set token budget, commit enough content to exceed threshold, call compile(), verify compression happened (HEAD changed, fewer commits visible)
   - Use manual compression by configuring CompressPolicy with autonomy that allows auto_commit (autonomous mode would need content="summary" in params -- adjust the test to either use collaborative mode with approve, or configure the policy to use content="Summary" for manual mode)
   - Actually, the simplest approach: configure CompressPolicy and use collaborative mode. After compile(), check that a proposal was created. Then approve it. This tests the full lifecycle without LLM.
   - Alternative: Set the CompressPolicy autonomy to "autonomous" and provide `content` param in the PolicyAction.params so compress() uses manual mode. Adjust CompressPolicy to accept `summary_text` in constructor for testing.
3. `test_policy_priority_ordering` -- register PinPolicy (priority=100) and CompressPolicy (priority=200), verify pin runs before compress (check audit log order)
4. `test_pause_resume_lifecycle` -- configure policies, pause, commit content, verify no policy fires, resume, commit again, verify policy fires
5. `test_collaborative_approve_reject` -- configure a policy in collaborative mode, trigger it, verify proposal created, approve it, verify action executed. Then trigger again, reject it.
6. `test_policy_config_persistence` -- save policy config, close tract, reopen, load config, verify it matches. (Note: built-in policy auto-instantiation from config is a bonus; at minimum test that the JSON roundtrips.)
7. `test_recursive_evaluation_prevention` -- create a custom policy whose evaluate() calls tract.compile(). Verify no infinite recursion (the recursion guard prevents it).
8. `test_multiple_policies_compose` -- register PinPolicy + CompressPolicy, commit InstructionContent that pushes over token threshold, verify pin happens on commit and compress proposal created on compile
9. `test_custom_policy_subclass` -- create a user-defined Policy subclass, register it, verify it evaluates correctly
10. `test_on_proposal_callback` -- configure with on_proposal callback, trigger collaborative policy, verify callback is called with PolicyProposal

For compress tests: use `TokenBudgetConfig(max_tokens=200, action=BudgetAction.WARN)` so budget doesn't block commits. Commit enough dialogue messages to push over the threshold. For manual compression in autonomous mode, the CompressPolicy should set `params={"content": "Compressed summary", "auto_commit": True}` in the action so compress() uses manual mode (no LLM needed).

Adjust CompressPolicy to accept `summary_content: str | None = None` in constructor. If provided, include `"content": summary_content` in the PolicyAction params. This enables testing without LLM. Default is None (requires LLM or collaborative review).
  </action>
  <verify>
Run `python -m pytest tests/test_policy_builtin.py tests/test_policy_integration.py -v` -- all tests pass. Run `python -m pytest tests/ -x --timeout=180` to confirm no regressions across the full suite.
  </verify>
  <done>
All built-in policy unit tests pass (CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy). All integration tests pass covering: auto-pin on commit, auto-compress on compile, priority ordering, pause/resume, collaborative approve/reject, config persistence, recursion prevention, policy composition, custom policies, and on_proposal callback. Zero regressions in existing test suite.
  </done>
</task>

</tasks>

<verification>
- `python -c "from tract import CompressPolicy, PinPolicy, BranchPolicy, RebasePolicy; print('builtin OK')"`
- `python -m pytest tests/test_policy_builtin.py -v` -- all pass
- `python -m pytest tests/test_policy_integration.py -v` -- all pass
- `python -m pytest tests/ -x --timeout=180` -- no regressions
- Verify priority ordering: PinPolicy.priority (100) < CompressPolicy.priority (200) < BranchPolicy.priority (300) < RebasePolicy.priority (500)
</verification>

<success_criteria>
1. CompressPolicy fires at 90% token budget threshold (configurable), proposes compression in collaborative mode
2. PinPolicy auto-pins InstructionContent and SessionContent on commit, respects manual overrides, supports retroactive scan
3. BranchPolicy detects content type switching patterns and proposes tangent branches
4. RebasePolicy detects stale branches and proposes archiving to archive/ prefix
5. All policies have correct priority ordering (100, 200, 300, 500)
6. All policies support to_config/from_config serialization
7. End-to-end integration: configure -> commit -> evaluate -> execute works
8. Collaborative approve/reject lifecycle works
9. Policy composition works (multiple policies interact correctly via priority ordering)
10. All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-policy-engine/06-03-SUMMARY.md`
</output>
