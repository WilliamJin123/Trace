---
phase: 06-policy-engine
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/tract/policy/__init__.py
  - src/tract/policy/protocols.py
  - src/tract/policy/evaluator.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_policy_evaluator.py
autonomous: true

must_haves:
  truths:
    - "User can create a custom policy by subclassing Policy ABC"
    - "PolicyEvaluator iterates registered policies sorted by priority and dispatches actions"
    - "Policy evaluation does not recurse (recursion guard via _evaluating flag)"
    - "Policies can be paused and resumed globally via Tract methods"
    - "Tract.compile() triggers compile-triggered policies before compilation"
    - "Tract.commit() triggers commit-triggered policies after commit"
    - "Policy config persists to _trace_meta and survives restart"
    - "Audit log entries are created for every triggered policy evaluation"
    - "Collaborative mode creates PolicyProposal that user can approve/reject"
    - "Autonomous mode executes actions immediately without proposal"
  artifacts:
    - path: "src/tract/policy/protocols.py"
      provides: "Policy ABC with evaluate(), name, priority, trigger"
      contains: "class Policy"
    - path: "src/tract/policy/evaluator.py"
      provides: "PolicyEvaluator sidecar class"
      contains: "class PolicyEvaluator"
    - path: "src/tract/policy/__init__.py"
      provides: "Public exports for policy module"
      contains: "Policy"
    - path: "src/tract/tract.py"
      provides: "configure_policies, register_policy, pause/resume, compile/commit hooks"
      contains: "configure_policies"
    - path: "tests/test_policy_evaluator.py"
      provides: "Tests for Policy ABC, PolicyEvaluator, Tract integration"
      min_lines: 120
  key_links:
    - from: "src/tract/policy/evaluator.py"
      to: "src/tract/policy/protocols.py"
      via: "PolicyEvaluator accepts list[Policy]"
      pattern: "Policy"
    - from: "src/tract/tract.py"
      to: "src/tract/policy/evaluator.py"
      via: "Tract._policy_evaluator attribute"
      pattern: "_policy_evaluator"
    - from: "src/tract/policy/evaluator.py"
      to: "src/tract/storage/sqlite.py"
      via: "PolicyEvaluator uses SqlitePolicyRepository for proposals and audit log"
      pattern: "policy_repo"
    - from: "src/tract/tract.py"
      to: "src/tract/tract.py"
      via: "compile() calls self._policy_evaluator.evaluate('compile')"
      pattern: "evaluate.*compile"
---

<objective>
Create the Policy ABC, PolicyEvaluator sidecar, and integrate them into the Tract facade with compile/commit hooks, proposal flow, config persistence, and audit logging.

Purpose: This is the core engine that makes automatic policy evaluation possible. The evaluator is generic (iterates any Policy implementation), supports the full autonomy spectrum (autonomous/collaborative/manual), and integrates cleanly into the existing Tract lifecycle without modifying any existing operations.

Output: policy/ package with Protocol ABC and Evaluator, Tract facade additions (configure_policies, register_policy, pause/resume), compile/commit hooks, config persistence via _trace_meta, and comprehensive evaluator tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-policy-engine/06-CONTEXT.md
@.planning/phases/06-policy-engine/06-RESEARCH.md
@.planning/phases/06-policy-engine/06-01-SUMMARY.md
@src/tract/tract.py
@src/tract/__init__.py
@src/tract/models/policy.py
@src/tract/storage/sqlite.py
@src/tract/storage/schema.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Policy ABC and PolicyEvaluator</name>
  <files>
    src/tract/policy/__init__.py
    src/tract/policy/protocols.py
    src/tract/policy/evaluator.py
  </files>
  <action>
Create the `src/tract/policy/` package.

**policy/protocols.py** -- Policy ABC:
- `from __future__ import annotations` at top
- `from abc import ABC, abstractmethod`
- `if TYPE_CHECKING:` guard for `from tract.tract import Tract`

```python
class Policy(ABC):
    """Abstract base class for all policies.

    Users implement this to create custom policies.
    Built-in CompressPolicy, PinPolicy, etc. also implement this.
    """

    @abstractmethod
    def evaluate(self, tract: Tract) -> PolicyAction | None:
        """Evaluate whether this policy should fire.

        Must be FAST -- check thresholds only, no LLM calls.
        Returns PolicyAction if the policy wants to fire, None if conditions not met.
        """
        ...

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique name for this policy (e.g., 'auto-compress')."""
        ...

    @property
    def priority(self) -> int:
        """Execution priority. Lower runs first. Default 100."""
        return 100

    @property
    def trigger(self) -> str:
        """When this policy evaluates: 'compile' or 'commit'. Default 'compile'."""
        return "compile"
```

Import `PolicyAction` from `tract.models.policy`.

**policy/evaluator.py** -- PolicyEvaluator sidecar:
- `from __future__ import annotations` at top
- `import logging`, `import uuid`, `from datetime import datetime`
- `logger = logging.getLogger(__name__)`
- `if TYPE_CHECKING:` guard for Tract, SqlitePolicyRepository

Key design:
- Constructor: `__init__(self, tract: Tract, policies: list[Policy] | None = None, policy_repo: SqlitePolicyRepository | None = None, on_proposal: Callable[[PolicyProposal], None] | None = None)`
- Sort policies by priority on init
- `_paused: bool = False`
- `_evaluating: bool = False` -- recursion guard (CRITICAL, same pattern as Tract._in_batch)
- `_last_fired: dict[str, datetime] = {}` -- cooldown tracking
- `_cooldown_seconds: float = 0` -- configurable cooldown (default 0 = no cooldown)

Methods:
- `register(self, policy: Policy) -> None` -- add policy, re-sort by priority
- `unregister(self, policy_name: str) -> None` -- remove by name
- `pause(self) -> None` -- set _paused = True
- `resume(self) -> None` -- set _paused = False
- `is_paused` property returning _paused

- `evaluate(self, trigger: str = "compile") -> list[EvaluationResult]`:
  1. If `_paused` or `_evaluating`, return []
  2. Set `_evaluating = True` in try/finally
  3. Filter policies matching `trigger`
  4. For each policy:
     a. Check cooldown: if `policy.name` in `_last_fired` and elapsed < `_cooldown_seconds`, skip
     b. Check pending proposals: if `policy_repo` exists, check for existing pending proposal for this policy. If pending exists, skip (natural cooldown)
     c. Call `policy.evaluate(self._tract)` in try/except. On exception, log error and create EvaluationResult with outcome="error"
     d. If returns None, continue (no action needed)
     e. If returns PolicyAction:
        - If autonomy == "autonomous": call `_execute_action(policy, action)`, log result
        - If autonomy == "collaborative": call `_create_proposal(policy, action)`, return proposal via callback
        - If autonomy == "manual": skip execution, log as "skipped"
     f. Update `_last_fired[policy.name]` for cooldown
     g. Log audit entry via `_log_evaluation()`
  5. Return list of EvaluationResult

- `_execute_action(self, policy: Policy, action: PolicyAction) -> EvaluationResult`:
  - Dispatch based on `action.action_type`:
    - "compress": call `self._tract.compress(**action.params)`
    - "annotate": call `self._tract.annotate(**action.params)` -- convert "pinned"/"normal"/"skip" strings to Priority enum
    - "branch": call `self._tract.branch(**action.params)`
    - "archive": create new branch with archive name, copy pointer (branch rename)
  - Wrap in try/except, return EvaluationResult with appropriate outcome
  - On success, log the resulting commit_hash if available

- `_create_proposal(self, policy: Policy, action: PolicyAction) -> PolicyProposal`:
  - Create PolicyProposal with uuid4 id, policy.name, action, datetime.now()
  - Set `_execute_fn` to a closure that calls `_execute_action` and updates proposal status
  - If policy_repo, save PolicyProposalRow to database
  - If on_proposal callback, call it with the proposal
  - Return the proposal

- `_log_evaluation(self, policy: Policy, trigger: str, result: EvaluationResult) -> None`:
  - If policy_repo, create PolicyLogRow and save
  - Always log via logger.debug()

- `approve_proposal(self, proposal_id: str) -> object`:
  - If policy_repo, look up proposal, update status
  - Execute the stored action
  - Return result

- `reject_proposal(self, proposal_id: str, reason: str = "") -> None`:
  - If policy_repo, look up proposal, update status to "rejected"

- `get_pending_proposals(self) -> list[PolicyProposal]`:
  - If policy_repo, return pending proposals
  - Else return []

**policy/__init__.py** -- Public exports:
```python
from tract.policy.protocols import Policy
from tract.policy.evaluator import PolicyEvaluator

__all__ = ["Policy", "PolicyEvaluator"]
```
  </action>
  <verify>
Run `python -c "from tract.policy import Policy, PolicyEvaluator; print('OK')"` to confirm imports work.
  </verify>
  <done>
Policy ABC exists with evaluate(), name, priority, trigger. PolicyEvaluator exists with evaluate(), register(), pause/resume, recursion guard, proposal flow, and audit logging. policy/__init__.py exports both classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tract facade integration, config persistence, and tests</name>
  <files>
    src/tract/tract.py
    src/tract/__init__.py
    tests/test_policy_evaluator.py
  </files>
  <action>
**tract.py** -- Add policy integration. The following additions should be minimal and non-breaking:

1. In `__init__()`, add:
   - `self._policy_evaluator: PolicyEvaluator | None = None` (imported lazily)
   - `self._policy_repo: SqlitePolicyRepository | None = None`

2. In `open()`, after creating spawn_repo:
   - Create `policy_repo = SqlitePolicyRepository(session)` (import from sqlite.py)
   - Set `tract._policy_repo = policy_repo`
   - Load policy config from `_trace_meta`: query for key="policy_config", if found, deserialize JSON and instantiate built-in policies (deferred to Plan 03 -- for now, just load the JSON and store as `tract._policy_config_json`)

3. Add new public methods after the spawn relationship helpers section:

```python
def configure_policies(
    self,
    policies: list | None = None,
    *,
    on_proposal: Callable | None = None,
    cooldown_seconds: float = 0,
) -> None:
    """Configure the policy evaluator.

    Args:
        policies: List of Policy instances to register.
        on_proposal: Callback for collaborative mode proposals.
        cooldown_seconds: Minimum seconds between same-policy firings.
    """
    from tract.policy.evaluator import PolicyEvaluator
    self._policy_evaluator = PolicyEvaluator(
        tract=self,
        policies=policies,
        policy_repo=self._policy_repo,
        on_proposal=on_proposal,
        cooldown_seconds=cooldown_seconds,
    )

def register_policy(self, policy) -> None:
    """Register a policy at runtime."""
    if self._policy_evaluator is None:
        self.configure_policies()
    self._policy_evaluator.register(policy)

def unregister_policy(self, policy_name: str) -> None:
    """Remove a registered policy by name."""
    if self._policy_evaluator is not None:
        self._policy_evaluator.unregister(policy_name)

def pause_all_policies(self) -> None:
    """Emergency kill switch: pause all policy evaluation."""
    if self._policy_evaluator:
        self._policy_evaluator.pause()

def resume_all_policies(self) -> None:
    """Resume policy evaluation after pause."""
    if self._policy_evaluator:
        self._policy_evaluator.resume()

def get_pending_proposals(self):
    """Get all pending policy proposals."""
    if self._policy_evaluator is None:
        return []
    return self._policy_evaluator.get_pending_proposals()

def approve_proposal(self, proposal_id: str):
    """Approve a pending policy proposal."""
    if self._policy_evaluator is None:
        from tract.exceptions import PolicyExecutionError
        raise PolicyExecutionError("No policy evaluator configured")
    return self._policy_evaluator.approve_proposal(proposal_id)

def reject_proposal(self, proposal_id: str, reason: str = "") -> None:
    """Reject a pending policy proposal."""
    if self._policy_evaluator is None:
        from tract.exceptions import PolicyExecutionError
        raise PolicyExecutionError("No policy evaluator configured")
    self._policy_evaluator.reject_proposal(proposal_id, reason)

def save_policy_config(self, config_data: dict) -> None:
    """Persist policy configuration to database."""
    import json
    from tract.storage.schema import TraceMetaRow
    from sqlalchemy import select
    stmt = select(TraceMetaRow).where(TraceMetaRow.key == "policy_config")
    existing = self._session.execute(stmt).scalar_one_or_none()
    if existing is None:
        self._session.add(TraceMetaRow(key="policy_config", value=json.dumps(config_data)))
    else:
        existing.value = json.dumps(config_data)
    self._session.commit()

def load_policy_config(self) -> dict | None:
    """Load policy configuration from database."""
    import json
    from tract.storage.schema import TraceMetaRow
    from sqlalchemy import select
    stmt = select(TraceMetaRow).where(TraceMetaRow.key == "policy_config")
    row = self._session.execute(stmt).scalar_one_or_none()
    if row is None:
        return None
    return json.loads(row.value)
```

4. Modify `compile()` method: Add policy evaluation BEFORE the compilation logic. Insert at the top of compile() after checking for empty head but before the order/time-travel/cache logic:

```python
# Evaluate compile-triggered policies (before compilation)
if (
    hasattr(self, '_policy_evaluator')
    and self._policy_evaluator is not None
    and not self._in_batch
):
    self._policy_evaluator.evaluate(trigger="compile")
    # Re-read HEAD after policy evaluation (policies may have changed it)
    current_head = self.head
    if current_head is None:
        empty = CompiledContext(messages=[], token_count=0, commit_count=0, token_source="")
        if order is not None:
            return empty, []
        return empty
```

5. Modify `commit()` method: Add policy evaluation AFTER the commit succeeds (after `self._session.commit()` and cache updates). Insert before the `return info`:

```python
# Evaluate commit-triggered policies (after commit)
if (
    hasattr(self, '_policy_evaluator')
    and self._policy_evaluator is not None
    and not self._in_batch
):
    self._policy_evaluator.evaluate(trigger="commit")
```

6. Add `policy_evaluator` property:
```python
@property
def policy_evaluator(self):
    """The policy evaluator, or None if not configured."""
    return self._policy_evaluator
```

**__init__.py** -- Add policy exports:
- Import: `from tract.policy import Policy, PolicyEvaluator`
- Import: `from tract.models.policy import PolicyAction, PolicyProposal, EvaluationResult, PolicyLogEntry`
- Import: `from tract.exceptions import PolicyExecutionError, PolicyConfigError`
- Add all to `__all__` list

**tests/test_policy_evaluator.py** -- Comprehensive tests:

Create a `DummyPolicy(Policy)` that returns a configurable PolicyAction or None. Use it throughout:

1. Test Policy ABC can be subclassed and instantiated
2. Test PolicyEvaluator sorts policies by priority
3. Test evaluate() filters by trigger ("compile" vs "commit")
4. Test recursion guard: nested evaluate() calls return [] (mock a policy that calls tract.compile() inside evaluate())
5. Test pause/resume: paused evaluator returns []
6. Test autonomous mode: action is executed immediately (use DummyPolicy that returns annotate action, verify commit is annotated)
7. Test collaborative mode: action creates proposal, on_proposal callback is called, approve() executes
8. Test collaborative mode: reject() sets status
9. Test audit log: evaluation creates PolicyLogRow entries (verify via policy_repo.get_log())
10. Test cooldown: rapid evaluations within cooldown_seconds are skipped
11. Test pending proposal dedup: if a pending proposal exists for a policy, skip re-evaluation
12. Test Tract.configure_policies() creates evaluator
13. Test Tract.register_policy() adds policy to evaluator (auto-creates evaluator if needed)
14. Test Tract.pause_all_policies() and resume_all_policies()
15. Test Tract.compile() triggers compile-triggered policies
16. Test Tract.commit() triggers commit-triggered policies
17. Test save_policy_config() and load_policy_config() roundtrip persistence
18. Test policy evaluation error handling: exception in policy.evaluate() is caught and logged as error
19. Test _execute_action dispatches to correct Tract method (at least "annotate" and "compress")
20. Test get_pending_proposals returns only pending ones

Use `Tract.open(":memory:")` for integration tests. Use `from tract import InstructionContent, DialogueContent, Priority` for creating test data. For compress action tests, provide `content="summary"` in params for manual compression (avoids LLM dependency).
  </action>
  <verify>
Run `python -m pytest tests/test_policy_evaluator.py -v` -- all tests pass. Run `python -m pytest tests/ -x --timeout=120` to confirm no regressions.
  </verify>
  <done>
Tract has configure_policies(), register_policy(), unregister_policy(), pause/resume, get_pending_proposals(), approve/reject_proposal(), save/load_policy_config(). compile() triggers compile-triggered policies. commit() triggers commit-triggered policies. Recursion guard prevents infinite loops. Audit logging works. Collaborative mode creates proposals. All tests pass, zero regressions.
  </done>
</task>

</tasks>

<verification>
- `python -c "from tract import Policy, PolicyEvaluator, PolicyAction, PolicyProposal, EvaluationResult; print('imports OK')"`
- `python -c "from tract import PolicyExecutionError, PolicyConfigError; print('exceptions OK')"`
- `python -m pytest tests/test_policy_evaluator.py -v` -- all pass
- `python -m pytest tests/ -x --timeout=120` -- no regressions
</verification>

<success_criteria>
1. Policy ABC exists with evaluate(), name, priority, trigger abstract methods
2. PolicyEvaluator iterates policies by priority, dispatches actions, guards against recursion
3. Tract.configure_policies() creates evaluator; register_policy() adds at runtime
4. Tract.compile() and commit() trigger policy evaluation at correct points
5. Collaborative mode creates PolicyProposal with approve/reject lifecycle
6. Autonomous mode executes immediately
7. Audit log entries created for every triggered evaluation
8. Policy config persists to _trace_meta via save/load_policy_config()
9. pause/resume_all_policies() works as emergency kill switch
10. All evaluator tests pass, zero regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-policy-engine/06-02-SUMMARY.md`
</output>
