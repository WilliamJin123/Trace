---
phase: 06-policy-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/storage/schema.py
  - src/tract/storage/engine.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/models/policy.py
  - src/tract/exceptions.py
  - tests/test_policy_storage.py
autonomous: true

must_haves:
  truths:
    - "PolicyProposalRow and PolicyLogRow tables exist in the database after init_db()"
    - "Schema version is 5 for new databases and migrated databases"
    - "v4 databases auto-migrate to v5 on init_db()"
    - "PolicyRepository ABC defines all CRUD operations for proposals and log entries"
    - "SqlitePolicyRepository implements all ABC methods correctly"
    - "PolicyAction, PolicyProposal, and EvaluationResult domain models exist with correct fields"
    - "PolicyExecutionError and PolicyConfigError exceptions exist in the hierarchy"
  artifacts:
    - path: "src/tract/storage/schema.py"
      provides: "PolicyProposalRow and PolicyLogRow ORM models"
      contains: "class PolicyProposalRow"
    - path: "src/tract/storage/engine.py"
      provides: "v4->v5 migration"
      contains: "policy_proposals"
    - path: "src/tract/storage/repositories.py"
      provides: "PolicyRepository ABC"
      contains: "class PolicyRepository"
    - path: "src/tract/storage/sqlite.py"
      provides: "SqlitePolicyRepository implementation"
      contains: "class SqlitePolicyRepository"
    - path: "src/tract/models/policy.py"
      provides: "PolicyAction, PolicyProposal, EvaluationResult domain models"
      contains: "class PolicyAction"
    - path: "src/tract/exceptions.py"
      provides: "PolicyExecutionError, PolicyConfigError"
      contains: "class PolicyExecutionError"
    - path: "tests/test_policy_storage.py"
      provides: "Storage layer tests for policy tables and repository"
      min_lines: 80
  key_links:
    - from: "src/tract/storage/engine.py"
      to: "src/tract/storage/schema.py"
      via: "init_db() creates PolicyProposalRow/PolicyLogRow tables"
      pattern: "policy_proposals.*policy_log"
    - from: "src/tract/storage/sqlite.py"
      to: "src/tract/storage/repositories.py"
      via: "SqlitePolicyRepository implements PolicyRepository ABC"
      pattern: "class SqlitePolicyRepository\\(PolicyRepository\\)"
---

<objective>
Create the storage foundation for the policy engine: ORM schema tables (policy_proposals, policy_log), schema v5 migration, repository ABC + SQLite implementation, domain models, and policy-specific exceptions.

Purpose: Establishes the persistence layer that all policy evaluation, proposal management, and audit logging will build on. Follows the exact patterns used by compression (v2->v3) and spawn (v3->v4) storage additions.

Output: Two new DB tables, PolicyRepository ABC, SqlitePolicyRepository, domain models (PolicyAction, PolicyProposal, EvaluationResult), exceptions, and storage tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-policy-engine/06-CONTEXT.md
@.planning/phases/06-policy-engine/06-RESEARCH.md
@src/tract/storage/schema.py
@src/tract/storage/engine.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/models/compression.py
@src/tract/exceptions.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema, migration, domain models, and exceptions</name>
  <files>
    src/tract/storage/schema.py
    src/tract/storage/engine.py
    src/tract/models/policy.py
    src/tract/exceptions.py
  </files>
  <action>
**schema.py** -- Add two new ORM classes at the end of the file (before TraceMetaRow or after SpawnPointerRow):

1. `PolicyProposalRow(Base)`:
   - `__tablename__ = "policy_proposals"`
   - `proposal_id: Mapped[str] = mapped_column(String(64), primary_key=True)`
   - `tract_id: Mapped[str] = mapped_column(String(64), nullable=False, index=True)`
   - `policy_name: Mapped[str] = mapped_column(String(100), nullable=False)`
   - `action_type: Mapped[str] = mapped_column(String(50), nullable=False)`
   - `action_params_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)`
   - `reason: Mapped[Optional[str]] = mapped_column(Text, nullable=True)`
   - `status: Mapped[str] = mapped_column(String(20), nullable=False, default="pending")` -- values: "pending", "approved", "rejected", "expired", "executed"
   - `created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)`
   - `resolved_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)`
   - `__table_args__` with composite index on `(tract_id, status)` named `ix_policy_proposals_tract_status`

2. `PolicyLogRow(Base)`:
   - `__tablename__ = "policy_log"`
   - `id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)`
   - `tract_id: Mapped[str] = mapped_column(String(64), nullable=False, index=True)`
   - `policy_name: Mapped[str] = mapped_column(String(100), nullable=False)`
   - `trigger: Mapped[str] = mapped_column(String(20), nullable=False)` -- "compile" or "commit"
   - `action_type: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)`
   - `reason: Mapped[Optional[str]] = mapped_column(Text, nullable=True)`
   - `outcome: Mapped[str] = mapped_column(String(20), nullable=False)` -- "executed", "proposed", "skipped", "error"
   - `commit_hash: Mapped[Optional[str]] = mapped_column(String(64), nullable=True)` -- the commit produced by this action, if any
   - `error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)`
   - `created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)`
   - `__table_args__` with composite index on `(tract_id, created_at)` named `ix_policy_log_tract_time`

Follow the exact import and declaration patterns used by existing ORM classes (use `from __future__ import annotations`, same `Mapped`, `mapped_column` style).

**engine.py** -- Add v4->v5 migration block after the v3->v4 block in `init_db()`:
```python
if existing is not None and existing.value == "4":
    # Migrate v4 -> v5: create policy tables
    for table_name in ["policy_proposals", "policy_log"]:
        Base.metadata.tables[table_name].create(engine, checkfirst=True)
    existing.value = "5"
    session.commit()
```
Update the new-database version from `"4"` to `"5"`. Update the docstring to mention v5.

**models/policy.py** -- Create new file with domain models:
- `from __future__ import annotations` at top
- Use `if TYPE_CHECKING:` for Tract import
- `@dataclass(frozen=True) class PolicyAction`: action_type (str), params (dict, default_factory=dict), reason (str, default=""), autonomy (str, default="collaborative")
- `@dataclass class PolicyProposal` (MUTABLE, follows PendingCompression pattern): proposal_id (str), policy_name (str), action (PolicyAction), created_at (datetime), status (str, default="pending"), `_execute_fn: Callable | None = field(default=None, repr=False)`. Add `approve() -> object` method that calls _execute_fn(self), `reject(reason: str = "") -> None` that sets status="rejected"
- `@dataclass(frozen=True) class EvaluationResult`: policy_name (str), triggered (bool), action (PolicyAction | None, default=None), outcome (str, default="skipped"), error (str | None, default=None), commit_hash (str | None, default=None)
- `@dataclass(frozen=True) class PolicyLogEntry`: id (int), tract_id (str), policy_name (str), trigger (str), action_type (str | None), reason (str | None), outcome (str), commit_hash (str | None), error_message (str | None), created_at (datetime)

**exceptions.py** -- Add two new exceptions at the end:
- `class PolicyExecutionError(TraceError): """Raised when a policy action fails to execute."""`
- `class PolicyConfigError(TraceError): """Raised when policy configuration is invalid."""`
  </action>
  <verify>
Run `python -c "from tract.storage.schema import PolicyProposalRow, PolicyLogRow; print('OK')"` and `python -c "from tract.models.policy import PolicyAction, PolicyProposal, EvaluationResult, PolicyLogEntry; print('OK')"` and `python -c "from tract.exceptions import PolicyExecutionError, PolicyConfigError; print('OK')"`.
  </verify>
  <done>
PolicyProposalRow and PolicyLogRow ORM classes exist in schema.py. init_db() creates v5 schema (new databases start at v5, v4 databases migrate). PolicyAction, PolicyProposal, EvaluationResult, PolicyLogEntry domain models exist. PolicyExecutionError and PolicyConfigError exceptions exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: PolicyRepository ABC, SqlitePolicyRepository, and storage tests</name>
  <files>
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    tests/test_policy_storage.py
  </files>
  <action>
**repositories.py** -- Add `PolicyRepository(ABC)` class at the end. Import `PolicyLogRow` and `PolicyProposalRow` in the `TYPE_CHECKING` block alongside existing schema imports. Methods:

- `save_proposal(self, proposal: PolicyProposalRow) -> None` -- abstract
- `get_proposal(self, proposal_id: str) -> PolicyProposalRow | None` -- abstract
- `get_pending_proposals(self, tract_id: str) -> list[PolicyProposalRow]` -- abstract, returns proposals with status="pending"
- `update_proposal_status(self, proposal_id: str, status: str, resolved_at: datetime) -> None` -- abstract
- `save_log_entry(self, entry: PolicyLogRow) -> None` -- abstract
- `get_log(self, tract_id: str, *, since: datetime | None = None, until: datetime | None = None, policy_name: str | None = None, limit: int = 100) -> list[PolicyLogRow]` -- abstract, returns entries ordered by created_at DESC
- `delete_log_entries(self, tract_id: str, before: datetime) -> int` -- abstract, for audit log GC, returns count deleted

**sqlite.py** -- Add `SqlitePolicyRepository(PolicyRepository)` class at the end. Import `PolicyRepository` in the repository imports, import `PolicyProposalRow, PolicyLogRow` in the schema imports. Follow exact pattern of SqliteSpawnPointerRepository:

- Constructor takes `session: Session`
- `save_proposal`: `self._session.add(proposal)` then `self._session.flush()`
- `get_proposal`: select by proposal_id, `scalar_one_or_none()`
- `get_pending_proposals`: select where tract_id matches AND status="pending", order by created_at ASC
- `update_proposal_status`: select proposal, update fields, flush
- `save_log_entry`: add + flush
- `get_log`: select with optional where clauses (since, until, policy_name), order by created_at DESC, limit
- `delete_log_entries`: delete where tract_id matches AND created_at < before, return rowcount

**tests/test_policy_storage.py** -- Create test file. Follow patterns from tests/test_compression_storage.py and tests/test_spawn_storage.py:

- Test schema migration v4->v5 (create v4 database, call init_db, verify tables exist, verify version=5)
- Test new database starts at v5
- Test save_proposal + get_proposal roundtrip
- Test get_pending_proposals returns only pending status
- Test update_proposal_status changes status and sets resolved_at
- Test save_log_entry + get_log roundtrip
- Test get_log with filters (since, until, policy_name)
- Test get_log ordering (DESC by created_at)
- Test get_log limit
- Test delete_log_entries
- Test full v1->v2->v3->v4->v5 migration chain (if a v1 database is opened, all migrations run)

Use `Tract.open(":memory:")` or direct engine/session fixtures as appropriate. Create helper functions as needed.
  </action>
  <verify>
Run `python -m pytest tests/test_policy_storage.py -v` -- all tests pass. Run `python -m pytest tests/ -x --timeout=120` to confirm no regressions.
  </verify>
  <done>
PolicyRepository ABC and SqlitePolicyRepository exist with all 7 methods. Storage tests pass covering migration, CRUD, filtering, ordering, and the full migration chain. Zero regressions in existing test suite.
  </done>
</task>

</tasks>

<verification>
- `python -c "from tract.storage.schema import PolicyProposalRow, PolicyLogRow; print('schema OK')"`
- `python -c "from tract.models.policy import PolicyAction, PolicyProposal, EvaluationResult; print('models OK')"`
- `python -c "from tract.exceptions import PolicyExecutionError, PolicyConfigError; print('exceptions OK')"`
- `python -c "from tract.storage.sqlite import SqlitePolicyRepository; print('repo OK')"`
- `python -m pytest tests/test_policy_storage.py -v` -- all pass
- `python -m pytest tests/ -x --timeout=120` -- no regressions
</verification>

<success_criteria>
1. New databases initialize at schema v5 with policy_proposals and policy_log tables
2. v4 databases auto-migrate to v5 on init_db()
3. Full v1->v5 migration chain works
4. PolicyRepository ABC defines 7 abstract methods
5. SqlitePolicyRepository implements all 7 methods with correct SQLAlchemy patterns
6. Domain models (PolicyAction, PolicyProposal, EvaluationResult, PolicyLogEntry) exist with correct fields
7. All new storage tests pass, zero regressions in existing 664 tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-policy-engine/06-01-SUMMARY.md`
</output>
