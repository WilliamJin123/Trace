---
phase: 03-branching-merging
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - src/tract/operations/rebase.py
  - src/tract/models/merge.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_rebase.py
autonomous: true

must_haves:
  truths:
    - "User can cherry-pick a specific commit from one branch into the current branch"
    - "Cherry-picked commit is a new commit with the same content but different parentage and hash"
    - "Cherry-pick detects when an EDIT commit's response_to target doesn't exist on the target branch"
    - "User can rebase the current branch onto a target branch"
    - "Rebase replays commits with new parents, producing new hashes"
    - "Rebase semantic safety checks detect when reordering changes meaning and block until resolved"
    - "All operations block on issues until resolver provides resolution (no warn-and-continue)"
  artifacts:
    - path: "src/tract/operations/rebase.py"
      provides: "Rebase and cherry-pick operations"
      exports: ["cherry_pick", "rebase", "replay_commit"]
    - path: "src/tract/models/merge.py"
      provides: "RebaseWarning and CherryPickIssue models (added to existing file)"
      contains: "class RebaseWarning"
    - path: "tests/test_rebase.py"
      provides: "Rebase and cherry-pick tests"
      min_lines: 250
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/operations/rebase.py"
      via: "Tract.cherry_pick() and Tract.rebase()"
      pattern: "from tract\\.operations\\.rebase import"
    - from: "src/tract/operations/rebase.py"
      to: "src/tract/operations/dag.py"
      via: "find_merge_base, get_branch_commits for identifying replay range"
      pattern: "from tract\\.operations\\.dag import"
    - from: "src/tract/operations/rebase.py"
      to: "src/tract/llm/protocols.py"
      via: "ResolverCallable for semantic safety checks"
      pattern: "ResolverCallable|Resolution"
    - from: "src/tract/operations/rebase.py"
      to: "src/tract/engine/commit.py"
      via: "CommitEngine.create_commit for replayed commits"
      pattern: "CommitEngine|create_commit"
---

<objective>
Implement rebase and cherry-pick operations with semantic safety checks: commit replay with new parentage, EDIT target remapping detection, and LLM-powered safety analysis for reordering.

Purpose: Rebase and cherry-pick complete the branching toolkit. Cherry-pick enables selective commit porting between branches. Rebase enables clean linear history by replaying commits. Safety checks prevent silently incoherent context.
Output: Working Tract.cherry_pick() and Tract.rebase() with safety checks, and comprehensive tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-branching-merging/03-CONTEXT.md
@.planning/phases/03-branching-merging/03-RESEARCH.md
@.planning/phases/03-branching-merging/03-01-SUMMARY.md
@.planning/phases/03-branching-merging/03-02-SUMMARY.md
@.planning/phases/03-branching-merging/03-03-SUMMARY.md

@src/tract/operations/dag.py
@src/tract/operations/merge.py
@src/tract/operations/branch.py
@src/tract/models/merge.py
@src/tract/models/commit.py
@src/tract/engine/commit.py
@src/tract/engine/hashing.py
@src/tract/llm/protocols.py
@src/tract/storage/repositories.py
@src/tract/exceptions.py
@src/tract/tract.py
@src/tract/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cherry-pick and rebase operations with safety checks</name>
  <files>
    src/tract/operations/rebase.py
    src/tract/models/merge.py
    src/tract/exceptions.py
  </files>
  <action>
1. **exceptions.py** -- Add rebase/cherry-pick exceptions:
   - `RebaseError(TraceError)`: Base for rebase errors.
   - `CherryPickError(TraceError)`: Base for cherry-pick errors.
   - `SemanticSafetyError(TraceError)`: Raised when safety check blocks and no resolver available.

2. **models/merge.py** -- Add issue types (append to existing file):
   ```python
   class RebaseWarning(BaseModel):
       """Semantic safety issue detected during rebase."""
       warning_type: Literal["reorder_changes_meaning", "edit_target_missing"]
       commit: CommitInfo  # The commit being replayed
       new_base: CommitInfo | None = None  # The new parent context
       original_base: CommitInfo | None = None
       context_before: list[CommitInfo] = []  # Commits before in original order
       context_after: list[CommitInfo] = []  # Commits after in new order
       description: str = ""

   class CherryPickIssue(BaseModel):
       """Issue detected during cherry-pick."""
       issue_type: Literal["edit_target_missing", "context_dependency"]
       commit: CommitInfo  # The commit being cherry-picked
       target_branch_head: CommitInfo | None = None
       missing_target: str | None = None  # The response_to hash that doesn't exist on target
       description: str = ""

   class RebaseResult(BaseModel):
       """Result of a rebase operation."""
       replayed_commits: list[CommitInfo] = []  # New commits created during replay
       original_commits: list[CommitInfo] = []  # Original commits that were replayed
       warnings: list[RebaseWarning] = []
       resolutions: dict[str, str] = {}  # commit_hash -> resolved content
       new_head: str | None = None

   class CherryPickResult(BaseModel):
       """Result of a cherry-pick operation."""
       original_commit: CommitInfo | None = None
       new_commit: CommitInfo | None = None
       issues: list[CherryPickIssue] = []
       resolutions: dict[str, str] = {}
   ```

3. **operations/rebase.py** -- Rebase and cherry-pick operations:

   **`replay_commit(original_row, new_parent_hash, commit_engine, blob_repo, *, response_to_remap=None) -> CommitInfo`:**
   - Load original content from blob_repo (get blob, parse JSON, validate_content).
   - If response_to_remap is provided and original has response_to, remap it.
   - Call commit_engine.create_commit() with:
     - Same content, operation, message, metadata, generation_config.
     - The new parent_hash is set because HEAD has been moved to new_parent_hash before calling.
   - Return the new CommitInfo.
   - NOTE: Before calling replay, the caller must ensure HEAD is at new_parent_hash. The commit engine reads HEAD internally.

   **`cherry_pick(commit_hash, tract_id, commit_repo, ref_repo, blob_repo, commit_engine, parent_repo=None, *, resolver=None) -> CherryPickResult`:**
   - Get the commit to cherry-pick.
   - Check for issues:
     - If EDIT commit: check if response_to target exists in current branch's history (use get_all_ancestors). If not, create CherryPickIssue(issue_type="edit_target_missing").
   - If issues and no resolver: raise CherryPickError with issue details.
   - If issues and resolver: call resolver with CherryPickIssue, get Resolution.
     - If resolution.action == "abort": raise CherryPickError.
     - If resolution.action == "resolved": use resolution.content_text as modified content.
     - If resolution.action == "skip": return CherryPickResult with no new commit.
   - Replay the commit: call replay_commit() or directly create a new commit with the cherry-picked content and current HEAD as parent.
   - For APPEND commits: straightforward copy of content blob, create new commit.
   - For EDIT commits (with target on current branch): create new EDIT commit with same response_to.
   - Session commit is handled by the Tract facade caller.
   - Return CherryPickResult.

   **`rebase(tract_id, target_branch, commit_repo, ref_repo, parent_repo, blob_repo, commit_engine, annotation_repo, *, resolver=None) -> RebaseResult`:**
   - Get current branch name and tip.
   - Get target branch tip.
   - Find merge_base between current and target.
   - Collect current branch commits (merge_base..current_tip) in chronological order.
   - **Semantic safety check:** For each commit being replayed, check if reordering affects meaning:
     - If commit is an EDIT: check if response_to target exists in the target branch history. If not, create RebaseWarning(warning_type="edit_target_missing").
     - Compare the original context ordering with the new ordering. If commits that were sequential now have different relative positions, create RebaseWarning(warning_type="reorder_changes_meaning"). (Simplified heuristic: only flag if EDIT commits are present, since APPEND-only rebase preserves meaning.)
   - If warnings and no resolver: raise SemanticSafetyError with warning details.
   - If warnings and resolver: call resolver for each warning.
     - If any resolution.action == "abort": raise RebaseError.
   - **Replay commits:**
     - Detach HEAD at target branch tip (or move branch pointer).
     - For each commit in chronological order, replay onto new parent.
     - After all replayed, update current branch ref to point at the last replayed commit.
     - Re-attach HEAD to current branch.
   - Return RebaseResult with replayed_commits.
  </action>
  <verify>
    `python -c "from tract.operations.rebase import cherry_pick, rebase, replay_commit"` succeeds.
    `python -c "from tract.models.merge import RebaseWarning, CherryPickIssue, RebaseResult"` succeeds.
    `python -m pytest tests/ -x -q` -- existing tests pass.
  </verify>
  <done>Cherry-pick and rebase operations implemented with semantic safety checks. Issue types defined. Replay mechanism creates new commits with correct parentage.</done>
</task>

<task type="auto">
  <name>Task 2: Tract facade methods and comprehensive tests</name>
  <files>
    src/tract/tract.py
    src/tract/__init__.py
    tests/test_rebase.py
  </files>
  <action>
1. **tract.py** -- Add cherry-pick and rebase facade methods:
   - `cherry_pick(commit_hash: str, *, resolver=None) -> CherryPickResult`:
     - Resolve commit_hash via resolve_commit().
     - Determine resolver: explicit > self._default_resolver > None.
     - Call operations.rebase.cherry_pick().
     - self._session.commit().
     - Clear compile cache.
     - Return result.
   - `rebase(target_branch: str, *, resolver=None) -> RebaseResult`:
     - Determine resolver: explicit > self._default_resolver > None.
     - Call operations.rebase.rebase().
     - self._session.commit().
     - Clear compile cache.
     - Return result.

2. **__init__.py** -- Export new types:
   - Add `RebaseWarning`, `CherryPickIssue`, `RebaseResult`, `CherryPickResult`, `RebaseError`, `CherryPickError`, `SemanticSafetyError` to imports and `__all__`.

3. **tests/test_rebase.py** -- Comprehensive test suite (~250+ lines):

   **Cherry-pick tests:**
   - `test_cherry_pick_append_commit`: Cherry-pick an APPEND commit from feature to main. Verify new commit has same content but different hash and different parent.
   - `test_cherry_pick_preserves_content`: Verify cherry-picked commit's blob content is identical to original.
   - `test_cherry_pick_preserves_metadata`: message, metadata, generation_config preserved.
   - `test_cherry_pick_edit_with_target_on_branch`: Cherry-pick EDIT commit where response_to target exists on current branch. Works fine.
   - `test_cherry_pick_edit_missing_target`: Cherry-pick EDIT commit where response_to target does NOT exist on current branch. Raises CherryPickError (no resolver).
   - `test_cherry_pick_edit_missing_target_with_resolver`: Same scenario but with mock resolver. Resolver returns resolved content, cherry-pick succeeds with adapted content.
   - `test_cherry_pick_from_commit_hash`: Cherry-pick by full commit hash (not just branch tip).

   **Rebase tests:**
   - `test_rebase_simple`: Create branch with 2 APPEND commits, commit on main after branch point, rebase feature onto main. Verify feature branch now has main commits as ancestors, and feature commits have new hashes.
   - `test_rebase_preserves_content`: After rebase, compile() on feature branch produces same messages in same order (just with main's commits prepended).
   - `test_rebase_updates_branch_pointer`: After rebase, feature branch ref points at the last replayed commit.
   - `test_rebase_with_edit_missing_target`: Feature has EDIT targeting a commit that only exists on feature (pre-merge-base). Rebase onto main. SemanticSafetyError raised (no resolver).
   - `test_rebase_with_resolver`: Same scenario with mock resolver. Resolver resolves, rebase succeeds.
   - `test_rebase_abort_on_safety`: Resolver returns action="abort". RebaseError raised.
   - `test_rebase_noop`: Rebase onto target when current is already ahead. Result has no replayed commits (or raises appropriate error).

   **Integration tests:**
   - `test_cherry_pick_then_compile`: Cherry-pick commit, verify compile() includes the new commit's content.
   - `test_rebase_then_merge`: Rebase feature onto main, then merge (should fast-forward since feature is ahead).
   - `test_full_branching_workflow`: Create branch, diverge, cherry-pick one commit, rebase, merge. Verify final state is coherent.

   **Safety check tests:**
   - `test_safety_check_blocks_without_resolver`: Operation with semantic issue and no resolver raises error.
   - `test_safety_check_passes_with_resolver`: Same operation with resolver succeeds.

   All tests use `Tract.open()`. Create helper function `setup_diverged_branches(t)` that creates a common setup.
  </action>
  <verify>
    `python -m pytest tests/test_rebase.py -x -q` -- all new tests pass.
    `python -m pytest tests/ -x -q` -- all tests pass (existing + branch + llm + merge + rebase).
  </verify>
  <done>
    - `tract.cherry_pick(hash)` copies a commit to the current branch with new hash
    - Cherry-pick detects EDIT target missing on target branch
    - `tract.rebase("main")` replays current branch commits onto main
    - Rebase produces new commits with correct parentage
    - Safety checks block on issues without resolver
    - All existing + new tests pass
  </done>
</task>

</tasks>

<verification>
1. All existing tests pass (zero regressions)
2. All rebase/cherry-pick tests pass
3. Manual smoke test:
   ```python
   from tract import Tract, InstructionContent, DialogueContent
   t = Tract.open()
   t.commit(InstructionContent(text="base"))
   base_hash = t.head
   t.branch("feature")
   feat1 = t.commit(DialogueContent(role="user", text="feature 1"))
   feat2 = t.commit(DialogueContent(role="user", text="feature 2"))
   t.switch("main")
   t.commit(DialogueContent(role="user", text="main work"))

   # Cherry-pick
   cp = t.cherry_pick(feat1.commit_hash)
   assert cp.new_commit is not None
   assert cp.new_commit.commit_hash != feat1.commit_hash

   # Rebase
   t.switch("feature")
   result = t.rebase("main")
   assert len(result.replayed_commits) == 2
   t.close()
   ```
</verification>

<success_criteria>
- Cherry-pick creates new commit with same content but different hash/parent
- Cherry-pick detects EDIT target issues and blocks/resolves appropriately
- Rebase replays commits with new parentage
- Semantic safety checks block when reordering affects meaning (EDIT present)
- All safety checks follow block-until-resolved pattern
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-branching-merging/03-04-SUMMARY.md`
</output>
