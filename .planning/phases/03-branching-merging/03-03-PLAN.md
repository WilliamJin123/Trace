---
phase: 03-branching-merging
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/tract/models/merge.py
  - src/tract/operations/merge.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_merge.py
autonomous: true

must_haves:
  truths:
    - "Fast-forward merge moves branch pointer without creating merge commit"
    - "Divergent merge with only APPENDs auto-merges with branch-blocks ordering and creates merge commit with two parents"
    - "Structural conflicts (both EDIT same commit, SKIP vs EDIT, EDIT+APPEND) are detected and block merge"
    - "Conflict merge returns MergeResult for review; user finalizes with commit_merge()"
    - "LLM-mediated semantic merge resolves conflicts via resolver callable"
    - "Merge commit has two parents recorded in commit_parents table"
    - "Compiled context after merge includes commits from both branches"
  artifacts:
    - path: "src/tract/models/merge.py"
      provides: "MergeResult, ConflictInfo, MergeConflict models"
      contains: "class MergeResult"
    - path: "src/tract/operations/merge.py"
      provides: "Merge strategies and conflict detection"
      exports: ["merge_branches", "detect_conflicts", "create_merge_commit"]
    - path: "tests/test_merge.py"
      provides: "Merge operation tests"
      min_lines: 300
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/operations/merge.py"
      via: "Tract.merge() and Tract.commit_merge()"
      pattern: "from tract\\.operations\\.merge import"
    - from: "src/tract/operations/merge.py"
      to: "src/tract/operations/dag.py"
      via: "find_merge_base, get_branch_commits for conflict detection"
      pattern: "from tract\\.operations\\.dag import"
    - from: "src/tract/operations/merge.py"
      to: "src/tract/llm/protocols.py"
      via: "ResolverCallable for LLM-mediated resolution"
      pattern: "ResolverCallable|Resolution"
    - from: "src/tract/operations/merge.py"
      to: "src/tract/storage/repositories.py"
      via: "CommitParentRepository for recording merge parents"
      pattern: "CommitParentRepository|add_parents"
---

<objective>
Implement merge strategies: fast-forward, divergent auto-merge with branch-blocks ordering, structural conflict detection, LLM-mediated semantic merge, and the MergeResult review flow.

Purpose: Merging is the core branching operation -- without it, branches are useless divergent histories. This plan delivers the full merge pipeline from simple fast-forward to LLM-resolved conflicts.
Output: Working Tract.merge() and Tract.commit_merge() with all merge strategies, conflict detection, and comprehensive tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-branching-merging/03-CONTEXT.md
@.planning/phases/03-branching-merging/03-RESEARCH.md
@.planning/phases/03-branching-merging/03-01-SUMMARY.md
@.planning/phases/03-branching-merging/03-02-SUMMARY.md

@src/tract/storage/schema.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/operations/dag.py
@src/tract/operations/branch.py
@src/tract/models/branch.py
@src/tract/models/commit.py
@src/tract/engine/hashing.py
@src/tract/engine/commit.py
@src/tract/engine/compiler.py
@src/tract/llm/protocols.py
@src/tract/llm/resolver.py
@src/tract/llm/errors.py
@src/tract/exceptions.py
@src/tract/tract.py
@src/tract/__init__.py
@src/tract/protocols.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Merge models and conflict detection</name>
  <files>
    src/tract/models/merge.py
    src/tract/operations/merge.py
    src/tract/exceptions.py
  </files>
  <action>
1. **exceptions.py** -- Add merge-related exceptions:
   - `MergeError(TraceError)`: Base for merge errors.
   - `MergeConflictError(MergeError)`: Raised when conflicts detected and no resolver available.
   - `NothingToMergeError(MergeError)`: Branch already up-to-date.

2. **models/merge.py** -- Merge data models (Pydantic):
   ```python
   from pydantic import BaseModel
   from typing import Optional, Literal
   from tract.models.commit import CommitInfo

   class ConflictInfo(BaseModel):
       """Rich context for a single conflict, passed to resolver."""
       conflict_type: Literal["both_edit", "skip_vs_edit", "edit_plus_append"]
       commit_a: CommitInfo  # From current branch
       commit_b: CommitInfo  # From source branch
       content_a_text: str = ""  # Pre-loaded content text from commit_a's blob
       content_b_text: str = ""  # Pre-loaded content text from commit_b's blob
       ancestor: CommitInfo | None = None  # Common ancestor if applicable
       ancestor_content_text: str | None = None  # Pre-loaded ancestor content text
       target_hash: str | None = None  # The commit being conflicted over (edit_target target)
       branch_a_commits: list[CommitInfo] = []
       branch_b_commits: list[CommitInfo] = []

   class MergeResult(BaseModel):
       """Result of a merge operation. Returned for review before commit."""
       merge_type: Literal["fast_forward", "clean", "conflict", "semantic"]
       source_branch: str
       target_branch: str
       merge_base_hash: str | None = None
       conflicts: list[ConflictInfo] = []
       resolutions: dict[str, str] = {}  # target_hash -> resolved content text
       resolution_reasoning: dict[str, str] = {}  # target_hash -> LLM reasoning
       auto_merged_content: list[CommitInfo] = []  # Commits that auto-merged cleanly
       generation_configs: dict[str, dict] = {}  # target_hash -> gen config from resolver
       committed: bool = False  # Set True after commit_merge()
       merge_commit_hash: str | None = None  # Set after commit_merge()

       def edit_resolution(self, target_hash: str, new_content: str) -> None:
           """Edit a conflict resolution before committing."""
           self.resolutions[target_hash] = new_content

       class Config:
           arbitrary_types_allowed = True
   ```

3. **operations/merge.py** -- Core merge logic:

   **`detect_conflicts(branch_a_commits, branch_b_commits, annotation_repo, blob_repo, tract_id, merge_base_hash) -> list[ConflictInfo]`:**
   - When building ConflictInfo objects, **pre-load content text** from the blob for each conflicting commit (via `blob_repo.get()` + JSON parse + text extraction). Populate `content_a_text`, `content_b_text`, and `ancestor_content_text` fields. This ensures the resolver receives actual content, not just CommitInfo metadata.
   - Classify each commit by operation (APPEND or EDIT).
   - **Both EDIT same target:** If any EDIT in branch A has the same `edit_target` as an EDIT in branch B, that's a `both_edit` conflict.
   - **SKIP vs EDIT:** If branch A has a SKIP annotation on commit X, and branch B has an EDIT targeting X (or vice versa), that's a `skip_vs_edit` conflict. Query annotation_repo for SKIP status.
   - **EDIT + APPEND (split by target location):** If either branch has an EDIT targeting a **pre-merge-base** commit (shared history) and the other branch has APPENDs, that's an `edit_plus_append` conflict — the EDIT changes context that the other branch's appends may depend on. However, if an EDIT targets a **post-merge-base** commit (the branch's own divergent history), it is NOT a conflict with the other branch's appends, since the other branch never saw that commit. Pass `merge_base_hash` to `detect_conflicts()` for this check.
   - Return list of ConflictInfo objects.

   **`merge_branches(tract_id, source_branch, commit_repo, ref_repo, parent_repo, blob_repo, annotation_repo, commit_engine, token_counter, *, resolver=None, strategy="auto", no_ff=False) -> MergeResult`:**
   - Get current branch name from ref_repo. If detached, raise MergeError.
   - Resolve source_branch to commit hash via ref_repo.get_branch().
   - Get current HEAD hash.
   - **Fast-forward check:** Is current HEAD an ancestor of source tip? (Use `is_ancestor()` from dag.py.) If yes and not no_ff:
     - Move current branch pointer to source tip. Return MergeResult(merge_type="fast_forward").
   - **Find merge base:** `find_merge_base()` from dag.py.
   - If merge_base == source_tip: source is already merged (NothingToMergeError).
   - **Collect branch commits:** `get_branch_commits()` for each side.
   - **Detect conflicts.**
   - **No conflicts (clean merge):**
     - Build merge content: FreeformContent with message "Merged {source} into {target}".
     - Create merge commit via `create_merge_commit()` (see below).
     - Return MergeResult(merge_type="clean").
   - **Conflicts exist:**
     - If resolver is provided: call resolver for each conflict, collect resolutions.
     - If all resolved: build merge content incorporating resolutions, create merge commit if auto_commit.
     - If no resolver: return MergeResult(merge_type="conflict", conflicts=...) for user review.
   - **strategy="semantic":** After auto-merge, also call resolver on the full merged context for semantic review.

   Merge commit creation is handled by `CommitEngine.create_merge_commit()` (added in Task 2 of this plan). `operations/merge.py` calls it — does NOT duplicate the logic. See Task 2 for the full method specification.
  </action>
  <verify>
    `python -c "from tract.models.merge import ConflictInfo, MergeResult"` succeeds.
    `python -c "from tract.operations.merge import merge_branches, detect_conflicts"` succeeds.
    `python -m pytest tests/ -x -q` -- existing tests pass.
  </verify>
  <done>Merge models defined, conflict detection logic implemented, merge_branches function handles fast-forward, clean merge, and conflict flow. create_merge_commit records multiple parents.</done>
</task>

<task type="auto">
  <name>Task 2: Tract facade methods and comprehensive merge tests</name>
  <files>
    src/tract/tract.py
    src/tract/__init__.py
    src/tract/engine/commit.py
    tests/test_merge.py
  </files>
  <action>
1. **tract.py** -- Add merge facade methods:
   - `configure_llm(client: LLMClient) -> None`: Stores `self._llm_client = client`. Also creates a default `OpenAIResolver(client)` as `self._default_resolver`.
   - `merge(source_branch: str, *, resolver=None, strategy="auto", no_ff=False, auto_commit=False, model=None, delete_branch=False) -> MergeResult`:
     - Determine resolver: explicit > self._default_resolver > None.
     - If model is specified and resolver is self._default_resolver, create a new OpenAIResolver with that model override.
     - Call `merge_branches()` from operations/merge.py, passing all repo references.
     - If result.merge_type == "fast_forward": update branch pointer, session.commit().
     - If result.merge_type == "clean" or (conflict and all resolved): session.commit().
     - If result.merge_type == "conflict" and auto_commit=True and resolver produced resolutions: create merge commit, session.commit().
     - If delete_branch and merge actually committed (result.committed == True or result.merge_type == "fast_forward"): delete source branch ref. Do NOT delete if merge returned unresolved conflicts with committed=False.
     - Clear compile cache (merge changes HEAD).
     - Return MergeResult.
   - `commit_merge(result: MergeResult) -> CommitInfo`:
     - Validate result has resolutions for all conflicts.
     - Build merge content from resolutions (FreeformContent with merged text).
     - Create merge commit via engine.
     - session.commit().
     - Mark result.committed = True.
     - Clear compile cache.
     - Return CommitInfo for the merge commit.

2. **__init__.py** -- Export new types:
   - Add `MergeResult`, `ConflictInfo`, `MergeError`, `MergeConflictError`, `NothingToMergeError` to imports and `__all__`.

3. **engine/commit.py** -- Add `create_merge_commit()` method:
   - Add `parent_repo: CommitParentRepository | None = None` to `__init__`.
   - `create_merge_commit(content, parent_hashes, *, message=None, metadata=None, generation_config=None) -> CommitInfo`:
     - Very similar to create_commit() but:
     - `parent_hash = parent_hashes[0]` (first parent = current branch).
     - `extra_parents = parent_hashes[1:]` passed to compute_commit_hash.
     - After saving CommitRow, call `self._parent_repo.add_parents(commit_hash, parent_hashes)`.
     - Operation is always APPEND for merge commits.
     - No edit constraint checks (merge commits don't edit).

4. **tests/test_merge.py** -- Comprehensive test suite (~300+ lines):

   **Fast-forward tests:**
   - `test_fast_forward_merge`: Create branch, commit on it only, merge back to main. Verify main tip moves to branch tip, no merge commit created.
   - `test_fast_forward_no_ff`: Same scenario but with no_ff=True. Verify merge commit created with two parents.
   - `test_already_up_to_date`: Source branch is ancestor of current. Raises NothingToMergeError.

   **Clean merge tests (both APPEND only):**
   - `test_clean_merge_branch_blocks`: Diverge with APPENDs on both sides. Verify merge commit created, compiled context has branch-blocks ordering (all main commits, then all feature commits -- or the inverse depending on which is "current").
   - `test_clean_merge_two_parents`: Verify merge commit has entries in commit_parents table.
   - `test_compiled_after_merge`: After merge, compile() includes messages from both branches.

   **Conflict detection tests:**
   - `test_conflict_both_edit_same_target`: Both branches EDIT the same original commit. Verify ConflictInfo with conflict_type="both_edit".
   - `test_conflict_skip_vs_edit`: One branch SKIPs, other EDITs same commit. Verify conflict_type="skip_vs_edit".
   - `test_conflict_edit_plus_append`: One branch has EDIT, other has APPEND. Verify conflict_type="edit_plus_append".

   **Conflict resolution tests:**
   - `test_conflict_merge_without_resolver`: Conflicts detected, no resolver. Returns MergeResult with conflicts, committed=False.
   - `test_conflict_merge_with_resolver`: Provide mock resolver that returns Resolution(action="resolved", content_text="merged"). Verify merge completes.
   - `test_commit_merge_after_review`: Get MergeResult with conflicts, edit a resolution, call commit_merge(). Verify merge commit created.
   - `test_merge_with_auto_commit`: Resolver resolves, auto_commit=True. Verify single-step merge.
   - `test_merge_delete_branch`: merge with delete_branch=True. Verify source branch ref deleted.

   **Integration tests:**
   - `test_full_merge_workflow`: Branch, diverge, merge, verify compiled context.
   - `test_merge_preserves_generation_config`: Merge commit records generation_config from resolver.

   Use `Tract.open()` for all tests. Create helper function `diverge_branches(t)` that creates a branch, commits on both sides, and returns the branch names.
  </action>
  <verify>
    `python -m pytest tests/test_merge.py -x -q` -- all new tests pass.
    `python -m pytest tests/ -x -q` -- all tests pass (existing + branch + llm + merge).
  </verify>
  <done>
    - `tract.merge("feature")` fast-forwards when possible
    - `tract.merge("feature")` creates merge commit with two parents for diverged histories
    - Structural conflicts (both_edit, skip_vs_edit, edit_plus_append) detected and returned in MergeResult
    - MergeResult supports edit_resolution() and commit_merge() review flow
    - LLM resolver integration works (with mock)
    - Compiled context after merge includes both branches' messages
    - All existing + new tests pass
  </done>
</task>

</tasks>

<verification>
1. All existing tests pass (zero regressions)
2. All merge tests pass
3. Manual smoke test:
   ```python
   from tract import Tract, InstructionContent, DialogueContent
   t = Tract.open()
   t.commit(InstructionContent(text="base"))
   t.branch("feature")
   t.commit(DialogueContent(role="user", text="feature work"))
   t.switch("main")
   t.commit(DialogueContent(role="user", text="main work"))
   result = t.merge("feature")
   assert result.merge_type == "clean"
   compiled = t.compile()
   assert len(compiled.messages) >= 3  # base + main + feature
   t.close()
   ```
</verification>

<success_criteria>
- Fast-forward merge works (pointer move, no merge commit)
- Clean merge creates merge commit with two parents and branch-blocks ordering
- Structural conflict detection identifies all three conflict types
- MergeResult review flow works (get result, edit, commit_merge)
- LLM resolver integration works for conflict resolution
- Compiled context after merge includes all branch commits
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-branching-merging/03-03-SUMMARY.md`
</output>
