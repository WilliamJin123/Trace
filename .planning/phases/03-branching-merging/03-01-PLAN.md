---
phase: 03-branching-merging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/storage/schema.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/storage/engine.py
  - src/tract/engine/hashing.py
  - src/tract/engine/compiler.py
  - src/tract/operations/branch.py
  - src/tract/operations/dag.py
  - src/tract/models/branch.py
  - src/tract/exceptions.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_branch.py
autonomous: true

must_haves:
  truths:
    - "User can create a named branch from HEAD and it points at the same commit"
    - "User can switch between branches and each branch maintains independent commit history"
    - "User can list all branches and see which one is current"
    - "User can delete a branch that is not the current branch"
    - "Merge base can be found for two branches that diverged from a common ancestor"
    - "Compiler handles merge commits with multiple parents (topological walk)"
    - "Commit hash includes all parent hashes for merge commits"
  artifacts:
    - path: "src/tract/storage/schema.py"
      provides: "CommitParentRow association table"
      contains: "class CommitParentRow"
    - path: "src/tract/storage/repositories.py"
      provides: "CommitParentRepository ABC"
      contains: "class CommitParentRepository"
    - path: "src/tract/storage/sqlite.py"
      provides: "SqliteCommitParentRepository implementation"
      contains: "class SqliteCommitParentRepository"
    - path: "src/tract/operations/branch.py"
      provides: "Branch CRUD operations"
      exports: ["create_branch", "delete_branch", "list_branches"]
    - path: "src/tract/operations/dag.py"
      provides: "DAG utilities for merge base and ancestor queries"
      exports: ["find_merge_base", "get_all_ancestors", "get_branch_commits"]
    - path: "src/tract/models/branch.py"
      provides: "BranchInfo model"
      contains: "class BranchInfo"
    - path: "tests/test_branch.py"
      provides: "Branch and DAG operation tests"
      min_lines: 200
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/operations/branch.py"
      via: "Tract.branch(), Tract.switch(), Tract.list_branches(), Tract.delete_branch()"
      pattern: "from tract\\.operations\\.branch import"
    - from: "src/tract/operations/dag.py"
      to: "src/tract/storage/repositories.py"
      via: "CommitParentRepository for multi-parent traversal"
      pattern: "CommitParentRepository"
    - from: "src/tract/engine/compiler.py"
      to: "src/tract/storage/repositories.py"
      via: "CommitParentRepository for multi-parent chain walk"
      pattern: "parent_repo|commit_parent"
---

<objective>
Add branch management infrastructure: pointer-based branching, DAG utilities for merge base computation, multi-parent commit schema support, and compiler updates for merge commit traversal.

Purpose: Establishes the foundation for all merge/rebase/cherry-pick operations. Without branches and DAG traversal, no divergent history operations are possible.
Output: Working branch create/switch/delete/list on Tract facade, merge_base algorithm, CommitParentRow schema, compiler multi-parent support, and comprehensive tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-branching-merging/03-CONTEXT.md
@.planning/phases/03-branching-merging/03-RESEARCH.md

@src/tract/storage/schema.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/storage/engine.py
@src/tract/engine/hashing.py
@src/tract/engine/compiler.py
@src/tract/engine/commit.py
@src/tract/operations/navigation.py
@src/tract/models/commit.py
@src/tract/exceptions.py
@src/tract/tract.py
@src/tract/__init__.py
@src/tract/protocols.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema, repositories, hashing, and compiler updates for multi-parent commits</name>
  <files>
    src/tract/storage/schema.py
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    src/tract/storage/engine.py
    src/tract/engine/hashing.py
    src/tract/engine/compiler.py
  </files>
  <action>
1. **schema.py** -- Add `CommitParentRow` association table:
   ```python
   class CommitParentRow(Base):
       __tablename__ = "commit_parents"
       commit_hash: Mapped[str] = mapped_column(String(64), ForeignKey("commits.commit_hash"), primary_key=True)
       parent_hash: Mapped[str] = mapped_column(String(64), ForeignKey("commits.commit_hash"), primary_key=True)
       position: Mapped[int] = mapped_column(Integer, nullable=False)
       __table_args__ = (Index("ix_commit_parents_commit", "commit_hash"),)
   ```
   Position 0 = first parent (current branch tip), 1 = merged branch tip. Import Integer if not already imported (it is).

2. **repositories.py** -- Add `CommitParentRepository` ABC:
   ```python
   class CommitParentRepository(ABC):
       @abstractmethod
       def add_parent(self, commit_hash: str, parent_hash: str, position: int) -> None: ...
       @abstractmethod
       def get_parents(self, commit_hash: str) -> list[str]: ...
       @abstractmethod
       def add_parents(self, commit_hash: str, parent_hashes: list[str]) -> None: ...
   ```
   `get_parents()` returns parent hashes ordered by position. `add_parents()` is a batch method that inserts all parents with position = list index. Add `CommitParentRow` to the TYPE_CHECKING imports.

3. **sqlite.py** -- Add `SqliteCommitParentRepository`:
   ```python
   class SqliteCommitParentRepository(CommitParentRepository):
       def __init__(self, session: Session) -> None: ...
       def add_parent(self, commit_hash, parent_hash, position) -> None:
           self._session.add(CommitParentRow(...))
           self._session.flush()
       def get_parents(self, commit_hash) -> list[str]:
           # SELECT parent_hash FROM commit_parents WHERE commit_hash=? ORDER BY position
           ...
       def add_parents(self, commit_hash, parent_hashes) -> None:
           for i, ph in enumerate(parent_hashes):
               self._session.add(CommitParentRow(commit_hash=commit_hash, parent_hash=ph, position=i))
           self._session.flush()
   ```
   Import `CommitParentRepository` from repositories and `CommitParentRow` from schema.

4. **engine.py** (`storage/engine.py`) -- Update `init_db()`:
   - Change schema_version from "1" to "2" for NEW databases.
   - Add migration: if `schema_version == "1"`, create commit_parents table and update to "2". Use `Base.metadata.tables["commit_parents"].create(engine, checkfirst=True)` then update the meta row.
   - `Base.metadata.create_all(engine)` already handles new tables for fresh databases.

5. **hashing.py** -- Update `commit_hash()` to accept optional `extra_parents: list[str] | None = None`:
   - When extra_parents is provided and non-empty, add `"parent_hashes": sorted([parent_hash or ""] + extra_parents)` to the hash data dict. Sorting ensures determinism.
   - When extra_parents is None or empty, existing behavior is unchanged (backward compat).

6. **compiler.py** -- Update `DefaultContextCompiler`:
   - Add `parent_repo: CommitParentRepository | None = None` to `__init__()`. Store as `self._parent_repo`.
   - Update `_walk_chain()`: After building the ancestor list via `get_ancestors()` (first-parent walk), if `self._parent_repo` is not None, detect merge commits by checking `get_parents()` for each commit. When a merge commit is found, recursively walk the second parent's chain and insert those commits in topological order using "branch blocks" strategy (all first-parent commits in order, then second-parent's unique commits before the merge base, in order). Use a `seen` set to avoid duplicates.
   - This is the key change: the compiler must produce a flat ordered list of effective commits that includes both parents' histories for merge commits.
   - If `self._parent_repo` is None, fall back to existing first-parent-only behavior (backward compat for tests that don't inject parent_repo).
  </action>
  <verify>
    `python -m pytest tests/ -x -q` -- all 302 existing tests pass (backward compat).
    Manually verify CommitParentRow table is created in fresh DB:
    ```python
    from tract.storage.engine import create_trace_engine, init_db
    e = create_trace_engine()
    init_db(e)
    from sqlalchemy import inspect
    assert "commit_parents" in inspect(e).get_table_names()
    ```
  </verify>
  <done>CommitParentRow table exists, CommitParentRepository ABC and SQLite impl are available, commit_hash supports extra_parents, compiler handles multi-parent walks with branch-blocks ordering, all 302 existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Branch operations, DAG utilities, exceptions, and Tract facade methods</name>
  <files>
    src/tract/operations/branch.py
    src/tract/operations/dag.py
    src/tract/models/branch.py
    src/tract/exceptions.py
    src/tract/tract.py
    src/tract/__init__.py
    tests/test_branch.py
  </files>
  <action>
1. **exceptions.py** -- Add new exception classes:
   - `BranchExistsError(TraceError)`: takes branch_name, message "Branch already exists: {name}"
   - `BranchNotFoundError(TraceError)`: takes branch_name, message "Branch not found: {name}"
   - `InvalidBranchNameError(TraceError)`: takes name + reason
   - `UnmergedBranchError(TraceError)`: takes branch_name, message about unmerged commits

2. **models/branch.py** -- Add `BranchInfo` Pydantic model:
   ```python
   class BranchInfo(BaseModel):
       name: str
       commit_hash: str
       is_current: bool = False
       commit_count: int | None = None  # Populated in verbose mode
       description: str | None = None
   ```

3. **operations/branch.py** -- Branch CRUD functions:
   - `validate_branch_name(name: str)`: No `.lock`, no `..`, no whitespace, no `~^:?*[\`, no leading/trailing `.`, not empty. Raise `InvalidBranchNameError` on violation.
   - `create_branch(name, tract_id, ref_repo, commit_repo, *, source=None, switch=True) -> str`: Creates branch ref at source (default HEAD). Auto-switches if switch=True. Raises `BranchExistsError` if name taken.
   - `delete_branch(name, tract_id, ref_repo, commit_repo, parent_repo=None, *, force=False)`: Blocks on current branch (raise TraceError). Without force, checks if branch tip is reachable from current branch (via DAG) and raises `UnmergedBranchError` if not. Deletes the ref.
   - `list_branches(tract_id, ref_repo) -> list[str]`: Delegates to `ref_repo.list_branches()`.

4. **operations/dag.py** -- DAG utilities:
   - `find_merge_base(commit_repo, parent_repo, hash_a, hash_b) -> str | None`: BFS on ancestor sets. Walk all ancestors of A (following parent_hash AND commit_parents), then BFS from B to find first intersection. See RESEARCH.md Pattern 2.
   - `get_all_ancestors(commit_hash, commit_repo, parent_repo) -> set[str]`: Returns set of all ancestor hashes (following all parents). Used by merge base and reachability checks.
   - `get_branch_commits(commit_repo, parent_repo, branch_tip, merge_base) -> list[CommitRow]`: Returns commits between merge_base (exclusive) and branch_tip (inclusive) in chronological order (root to tip). Only follows first-parent chain. Used by merge to collect branch-specific commits.
   - `is_ancestor(commit_repo, parent_repo, potential_ancestor, commit_hash) -> bool`: Returns True if potential_ancestor is reachable from commit_hash.

5. **tract.py** -- Add facade methods and wire parent_repo:
   - In `open()` and `from_components()`: create `SqliteCommitParentRepository(session)`, store as `self._parent_repo`. Pass `parent_repo=self._parent_repo` to `DefaultContextCompiler`.
   - `branch(name, *, source=None, switch=True) -> str`: Delegates to `operations.branch.create_branch()`. Calls `self._session.commit()` after.
   - `switch(target) -> str`: Branch-only switching (like git switch, NOT git checkout). First validates that `target` is a branch name via `ref_repo.get_branch()`. If not a branch, raises `BranchNotFoundError(target)`. Only then delegates to `operations.navigation.checkout()`. This prevents `switch()` from silently detaching HEAD on commit hashes â€” use `checkout()` for that. Returns commit hash.
   - `list_branches() -> list[BranchInfo]`: Gets branch names via `operations.branch.list_branches()`, builds BranchInfo list with is_current flag.
   - `delete_branch(name, *, force=False)`: Delegates to `operations.branch.delete_branch()`. Calls `self._session.commit()` after.

6. **__init__.py** -- Export new public types:
   - Add `BranchInfo`, `BranchExistsError`, `BranchNotFoundError`, `InvalidBranchNameError`, `UnmergedBranchError` to imports and `__all__`.

7. **tests/test_branch.py** -- Comprehensive test suite (~200+ lines):
   - **Branch creation:** create from HEAD, create from specific commit, create with auto-switch, create without switch, duplicate name error, invalid name errors (empty, `..`, leading `.`, contains `~`, contains space, etc.)
   - **Branch switching:** switch to branch, switch back, verify independent histories (create branch, commit on each, verify different HEADs)
   - **Branch listing:** list with current flag, empty list before commits
   - **Branch deletion:** delete non-current branch, block delete current branch, force delete unmerged, block delete unmerged without force
   - **DAG utilities:** find_merge_base for linear history (returns earlier commit), find_merge_base for diverged branches (returns fork point), is_ancestor for direct ancestor, is_ancestor for non-ancestor, get_all_ancestors follows multi-parent, get_branch_commits returns correct range
   - **Compiler multi-parent:** Create merge scenario manually (insert CommitParentRow), verify compiler walks both parents
   - **Integration:** Full branch workflow -- create branch, commit on both, verify independent heads, verify merge_base returns fork point
  </action>
  <verify>
    `python -m pytest tests/test_branch.py -x -q` -- all new tests pass.
    `python -m pytest tests/ -x -q` -- all tests pass (302 existing + new).
  </verify>
  <done>
    - `tract.branch("feature")` creates a branch and switches to it
    - `tract.switch("main")` switches back, HEAD points at main's tip
    - Committing on each branch independently produces different HEADs
    - `tract.list_branches()` returns BranchInfo list with is_current=True for active branch
    - `tract.delete_branch("feature")` removes the ref (blocked for current branch)
    - `find_merge_base()` correctly identifies the fork point for diverged branches
    - All 302+ tests pass
  </done>
</task>

</tasks>

<verification>
1. All 302 existing tests pass (zero regressions)
2. New branch tests pass
3. Schema migration: fresh DB has commit_parents table, schema_version=2
4. Manual smoke test:
   ```python
   from tract import Tract, InstructionContent
   t = Tract.open()
   t.commit(InstructionContent(text="base"))
   t.branch("feature")  # Creates and switches
   t.commit(InstructionContent(text="on feature"))
   t.switch("main")
   t.commit(InstructionContent(text="on main"))
   assert t.head != t._ref_repo.get_branch(t.tract_id, "feature")
   branches = t.list_branches()
   assert len(branches) == 2
   t.close()
   ```
</verification>

<success_criteria>
- Branch create/switch/delete/list works through Tract facade
- Independent branch histories maintained (commits on one branch don't appear on other)
- find_merge_base returns correct fork point for diverged branches
- CommitParentRow schema exists and SqliteCommitParentRepository works
- Compiler handles multi-parent commit chains
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-branching-merging/03-01-SUMMARY.md`
</output>
